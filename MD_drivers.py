import ctypes
import os
import numpy as np

import matplotlib.pyplot as plt
from matplotlib import cm
import matplotlib as mpl
from mpl_toolkits.mplot3d.art3d import Poly3DCollection

import moordyn

# MoorPy Functions
def rotationMatrix(x3,x2,x1):
    '''Calculates a rotation matrix based on order-z,y,x instrinsic (tait-bryan?) angles, meaning
    they are about the ROTATED axes. (rotation about z-axis would be (0,0,theta) )
    
    Parameters
    ----------
    x3, x2, x1: floats
        The angles that the rotated axes are from the nonrotated axes. Normally roll,pitch,yaw respectively. [rad]

    Returns
    -------
    R : matrix
        The rotation matrix
    '''
    # initialize the sines and cosines
    s1 = np.sin(x1) 
    c1 = np.cos(x1)
    s2 = np.sin(x2) 
    c2 = np.cos(x2)
    s3 = np.sin(x3) 
    c3 = np.cos(x3)
    
    # create the rotation matrix
    R = np.array([[ c1*c2,  c1*s2*s3-c3*s1,  s1*s3+c1*c3*s2],
                  [ c2*s1,  c1*c3+s1*s2*s3,  c3*s1*s2-c1*s3],
                  [   -s2,           c2*s3,           c2*c3]])
    
    return R    

def set_axes_equal(ax):
    '''Sets 3D plot axes to equal scale

    Parameters
    ----------
    ax : matplotlib.pyplot axes
        the axes that are to be set equal in scale to each other.

    Returns
    -------
    None.

    '''
    
    rangex = np.diff(ax.get_xlim3d())[0]
    rangey = np.diff(ax.get_ylim3d())[0]
    rangez = np.diff(ax.get_zlim3d())[0]
    
    ax.set_box_aspect([rangex, rangey, rangez])  # note: this may require a matplotlib update

def makeTower(twrH, twrRad):
    '''Sets up mesh points for visualizing a cylindrical structure (should align with RAFT eventually.'''
    
    n = 8
    X = []
    Y = []
    Z = []
    ax=np.zeros(n+1)
    ay=np.zeros(n+1)
    for jj in range(n+1):
        ax[jj] = np.cos(float(jj)/float(n)*2.0*np.pi)
        ay[jj] = np.sin(float(jj)/float(n)*2.0*np.pi)
        
    for ii in range(int(len(twrRad)-1)):
        z0 = twrH*float(ii)/float(len(twrRad)-1)
        z1 = twrH*float(ii+1)/float(len(twrRad)-1)
        for jj in range(n+1):
            X.append(twrRad[ii]*ax[jj])
            Y.append(twrRad[ii]*ay[jj])
            Z.append(z0)            
            X.append(twrRad[ii+1]*ax[jj])
            Y.append(twrRad[ii+1]*ay[jj])
            Z.append(z1)
    
    Xs = np.array(X)
    Ys = np.array(Y)
    Zs = np.array(Z)    
    
    return Xs, Ys, Zs

def read_mooring_file(fileName, printing):
    # Taken from MoorPy
    # load data from time series for single mooring line
    
    if (printing > 0):
        print('MD_Driver: Loading '+fileName)
    
    f = open(fileName, 'r')
    
    channels = []
    units = []
    data = []
    i=0
    
    printed = False # Handling fortran output error where near 0 values are ***
    for line in f:          # loop through lines in file
        if len(line.split()) > 1 and ('predictions were generated by MoorDyn' not in line): # skip blank lines
            if (i == 0):
                for entry in line.split():      # loop over the elemets, split by whitespace
                    channels.append(entry)      # append to the last element of the list
            elif (i == 1):
                for entry in line.split():      # loop over the elemets, split by whitespace
                    units.append(entry)         # append to the last element of the list

            elif len(line.split()) > 0:
        
                data.append([])  # add a new sublist to the data matrix
                import re
                r = re.compile(r"(?<=\d)\-(?=\d)")  # catch any instances where a large negative exponent has been written with the "E"
                line2 = r.sub("E-",line)            # and add in the E
                
                for entry in line2.split():      # loop over the elemets, split by whitespace
                    if '***' in entry:
                        if printed == False:
                            if (printing > 0):
                                print('MD_Driver: *** found in {}. Defaulting to 0.0'.format(fileName))
                            printed = True
                        entry = 0.0   
                    data[-1].append(entry)      # append to the last element of the list
                
            else:
                break
        
            i+=1
    
    f.close()  # close data file
    
    # use a dictionary for convenient access of channel columns (eg. data[t][ch['PtfmPitch'] )
    ch = dict(zip(channels, range(len(channels))))
    
    data2 = np.array(data)
    
    data3 = data2.astype(float)

    return data3, ch, channels, units  
 
# MoorPy Classes
# base class for MoorPy exceptions
class Error(Exception):
    ''' Base class for MoorPy exceptions'''
    pass
# Line Object error class
class LineError(Error):
    '''Derived error class for Line object errors. Contains an error message and the line number with the error.'''
    def __init__(self, num, message):
        self.line_num = num
        self.message = message

class Line():
    '''A class for any mooring line that consists of a single material'''
    def __init__(self, mooringSys, num, L, lineType, nSegs=100, isRod=0, attachments = [0,0], coupled = 0, printing = 1):
        '''Initialize Line attributes
        Parameters
        ----------
        mooringSys : system object
            The system object that contains the point object
        num : int
            indentifier number
        L : float
            line unstretched length [m]
        lineType : dict
            dictionary containing the coefficients needed to describe the line (could reference an entry of System.lineTypes).
        nSegs : int, optional
            number of segments to split the line into. Used in MoorPy just for plotting. The default is 100.
        isRod : boolean, optional
            determines whether the line is a rod or not. The default is 0.
        attachments : TYPE, optional
            ID numbers of any Points attached to the Line. The default is [0,0]. << consider removing
        Returns
        -------
        None.
        '''

        self.printing = printing
        
        self.sys    = mooringSys       # store a reference to the overall mooring system (instance of System class)
        
        self.number = num
        self.isRod = isRod
            
        self.L = L  # line unstretched length
        self.type = lineType    # dictionary of a System.lineTypes entry

        self.nNodes = int(nSegs) + 1

        self.rA = np.zeros(3) # end coordinates
        self.rB = np.zeros(3)
        
        #Perhaps this could be made less intrusive by defining it using a line.addpoint() method instead, similar to point.attachline().
        self.attached = attachments  # ID numbers of the Points at the Line ends [a,b] >>> NOTE: not fully supported <<<<
        self.th = 0           # heading of line from end A to B
        self.info = {}        # to hold all info provided by catenary
        
        self.color = 'k'
        self.lw=0.5 # line weight for plt.plot function

        self.coupled = coupled # useful for determining state vector w/ coupled rod
    
    def loadData(self, dirname, rootname, sep='.MD.'):
        '''Loads line-specific time series data from a MoorDyn output file'''
    
        # load time series data
        if self.isRod > 0:
            data, ch, channels, units = read_mooring_file(dirname+rootname+sep+"Rod"+str(self.number)+".out", printing = self.printing) # remember number starts on 1 rather than 0
        else:
            data, ch, channels, units = read_mooring_file(dirname+rootname+sep+"Line"+str(self.number)+".out", printing = self.printing) # remember number starts on 1 rather than 0
                
        # get time info
        if ("Time" in ch):
            self.Tdata = data[:,ch["Time"]]
            self.dt = self.Tdata[1]-self.Tdata[0]
        else:
            raise LineError(self.number,"loadData: could not find Time channel for mooring line ")
    
        
        nT = len(self.Tdata)  # number of time steps
        
        # check for position data <<<<<<
        
        self.xp = np.zeros([nT,self.nNodes])
        self.yp = np.zeros([nT,self.nNodes])
        self.zp = np.zeros([nT,self.nNodes])
        
        
        for i in range(self.nNodes):
            self.xp[:,i] = data[:, ch['Node'+str(i)+'px']]
            self.yp[:,i] = data[:, ch['Node'+str(i)+'py']]
            self.zp[:,i] = data[:, ch['Node'+str(i)+'pz']]
            
        if self.isRod==0:
            self.Te = np.zeros([nT,self.nNodes-1])   # read in tension data if available
            if "Seg1Te" in ch:
                for i in range(self.nNodes-1):
                    self.Te[:,i] = data[:, ch['Seg'+str(i+1)+'Te']]
                    
            self.Ku = np.zeros([nT,self.nNodes])   # read in curvature data if available
            if "Node0Ku" in ch:
                for i in range(self.nNodes):
                    self.Ku[:,i] = data[:, ch['Node'+str(i)+'Ku']]

        self.Ux = np.zeros([nT,self.nNodes])   # read in fluid velocity data if available
        self.Uy = np.zeros([nT,self.nNodes])
        self.Uz = np.zeros([nT,self.nNodes])
        if "Node0Ux" in ch:
            for i in range(self.nNodes):
                self.Ux[:,i] = data[:, ch['Node'+str(i)+'Ux']]
                self.Uy[:,i] = data[:, ch['Node'+str(i)+'Uy']]
                self.Uz[:,i] = data[:, ch['Node'+str(i)+'Uz']]


        self.xpi= self.xp[0,:]
        self.ypi= self.yp[0,:]
        self.zpi= self.zp[0,:]
        
        # get length (constant)
        self.L = np.sqrt( (self.xpi[-1]-self.xpi[0])**2 + (self.ypi[-1]-self.ypi[0])**2 + (self.zpi[-1]-self.zpi[0])**2 )
        
    def getTimestep(self, Time):
        '''Get the time step to use for showing time series data'''
        
        if Time < 0: 
            ts = np.int(-Time)  # negative value indicates passing a time step index
        else:           # otherwise it's a time in s, so find closest time step
            for index, item in enumerate(self.Tdata):
                #print "index is "+str(index)+" and item is "+str(item)
                ts = -1
                if item > Time:
                    ts = index
                    break
            if ts==-1:
                raise LineError("getTimestep: requested time likely out of range")
                  
        return ts

    def getLineCoords(self, Time, n=0):    # formerly UpdateLine
        '''Gets the updated line coordinates for drawing and plotting purposes.'''
        
        # figure out what time step to use
        ts = self.getTimestep(Time)
        
        # drawing rods
        if self.isRod > 0:
        
            k1 = np.array([ self.xp[ts,-1]-self.xp[ts,0], self.yp[ts,-1]-self.yp[ts,0], self.zp[ts,-1]-self.zp[ts,0] ]) / self.L # unit vector
            
            k = np.array(k1) # make copy
        
            Rmat = np.array(rotationMatrix(0, np.arctan2(np.hypot(k[0],k[1]), k[2]), np.arctan2(k[1],k[0])))  # <<< should fix this up at some point, MattLib func may be wrong
            
            # make points for appropriately sized cylinder
            d = self.type['d_vol']
            Xs, Ys, Zs = makeTower(self.L, np.array([d, d]))   # add in makeTower method once you start using Rods
            
            # translate and rotate into proper position for Rod
            coords = np.vstack([Xs, Ys, Zs])
            newcoords = np.matmul(Rmat,coords)
            Xs = newcoords[0,:] + self.xp[ts,0]
            Ys = newcoords[1,:] + self.yp[ts,0]
            Zs = newcoords[2,:] + self.zp[ts,0]
            
            return Xs, Ys, Zs, None
            
        # drawing lines
        else:
            
            return self.xp[ts,:], self.yp[ts,:], self.zp[ts,:], self.Tdata[ts:]
    
    def drawLine2d(self, Time, ax, color="k", Xuvec=[1,0,0], Yuvec=[0,0,1], colortension=False, cmap='rainbow'):
        '''Draw the line on 2D plot (ax must be 2D)

        Parameters
        ----------
        Time : float
            time value at which to draw the line
        ax : axis
            the axis on which the line is to be drawn
        color : string, optional
            color identifier in one letter (k=black, b=blue,...). The default is "k".
        Xuvec : list, optional
            plane at which the x-axis is desired. The default is [1,0,0].
        Yuvec : list, optional
            plane at which the y-axis is desired. The default is [0,0,1].
        colortension : bool, optional
            toggle to plot the lines in a colormap based on node tensions. The default is False
        cmap : string, optional
            colormap string type to plot tensions when colortension=True. The default is 'rainbow'

        Returns
        -------
        linebit : list
            list of axes and points on which the line can be plotted

        '''
        
        linebit = []  # make empty list to hold plotted lines, however many there are
        
        if self.isRod > 0:
            
            Xs, Ys, Zs, Te = self.getLineCoords(Time)
        
            # apply any 3D to 2D transformation here to provide desired viewing angle
            Xs2d = Xs*Xuvec[0] + Ys*Xuvec[1] + Zs*Xuvec[2] 
            Ys2d = Xs*Yuvec[0] + Ys*Yuvec[1] + Zs*Yuvec[2] 
        
            for i in range(int(len(Xs)/2-1)):
                linebit.append(ax.plot(Xs2d[2*i:2*i+2]    ,Ys2d[2*i:2*i+2]    , lw=0.5, color=color))  # side edges
                linebit.append(ax.plot(Xs2d[[2*i,2*i+2]]  ,Ys2d[[2*i,2*i+2]]  , lw=0.5, color=color))  # end A edges
                linebit.append(ax.plot(Xs2d[[2*i+1,2*i+3]],Ys2d[[2*i+1,2*i+3]], lw=0.5, color=color))  # end B edges
        
        # drawing lines...
        else:

            Xs, Ys, Zs, Ts = self.getLineCoords(Time)
            self.rA = np.array([Xs[0], Ys[0], Zs[0]])
            self.rB = np.array([Xs[-1], Ys[-1], Zs[-1]])
            
            # apply any 3D to 2D transformation here to provide desired viewing angle
            Xs2d = Xs*Xuvec[0] + Ys*Xuvec[1] + Zs*Xuvec[2] 
            Ys2d = Xs*Yuvec[0] + Ys*Yuvec[1] + Zs*Yuvec[2] 
            
            if colortension:    # if the mooring lines want to be plotted with colors based on node tensions
                maxt = np.max(Ts); mint = np.min(Ts)
                for i in range(len(Xs)-1):          # for each node in the line
                    color_ratio = ((Ts[i] + Ts[i+1])/2 - mint)/(maxt - mint)  # ratio of the node tension in relation to the max and min tension
                    cmap_obj = cm.get_cmap(cmap)    # create a cmap object based on the desired colormap
                    rgba = cmap_obj(color_ratio)    # return the rbga values of the colormap of where the node tension is
                    linebit.append(ax.plot(Xs2d[i:i+2], Ys2d[i:i+2], color=rgba))
            else:
                linebit.append(ax.plot(Xs2d, Ys2d, lw=1, color=color)) # previously had lw=1 (linewidth)
            
        self.linebit = linebit # can we store this internally?
        
        self.X = np.array([Xs, Ys, Zs])
            
        return linebit

    def drawLine(self, Time, ax, color="k", endpoints=False, shadow=True, colortension=False, cmap_tension='rainbow'):
        '''Draw the line in 3D
        
        Parameters
        ----------
        Time : float
            time value at which to draw the line
        ax : axis
            the axis on which the line is to be drawn
        color : string, optional
            color identifier in one letter (k=black, b=blue,...). The default is "k".
        endpoints : bool, optional
            toggle to plot the end points of the lines. The default is False
        shadow : bool, optional
            toggle to plot the mooring line shadow on the seabed. The default is True
        colortension : bool, optional
            toggle to plot the lines in a colormap based on node tensions. The default is False
        cmap : string, optional
            colormap string type to plot tensions when colortension=True. The default is 'rainbow'
            
        Returns
        -------
        linebit : list
            list of axes and points on which the line can be plotted
        '''
        
        if color == 'self':
            color = self.color  # attempt to allow custom colors
            lw = self.lw
        else:
            lw = 1
        
        linebit = []  # make empty list to hold plotted lines, however many there are
    
        if self.isRod > 0:
            
            Xs, Ys, Zs, Ts = self.getLineCoords(Time)
            
            for i in range(int(len(Xs)/2-1)):
                linebit.append(ax.plot(Xs[2*i:2*i+2],Ys[2*i:2*i+2],Zs[2*i:2*i+2]            , color=color))  # side edges
                linebit.append(ax.plot(Xs[[2*i,2*i+2]],Ys[[2*i,2*i+2]],Zs[[2*i,2*i+2]]      , color=color))  # end A edges
                linebit.append(ax.plot(Xs[[2*i+1,2*i+3]],Ys[[2*i+1,2*i+3]],Zs[[2*i+1,2*i+3]], color=color))  # end B edges
            
            # scatter points for line ends 
            if endpoints == True:
                linebit.append(ax.scatter([Xs[0], Xs[-1]], [Ys[0], Ys[-1]], [Zs[0], Zs[-1]], color = color))
        
        # drawing lines...
        else:
            
            Xs, Ys, Zs, Ts = self.getLineCoords(Time)
            self.rA = np.array([Xs[0], Ys[0], Zs[0]])
            self.rB = np.array([Xs[-1], Ys[-1], Zs[-1]])
            
            if colortension:    # if the mooring lines want to be plotted with colors based on node tensions
                maxt = np.max(Ts); mint = np.min(Ts)
                for i in range(len(Xs)-1):          # for each node in the line
                    color_ratio = ((Ts[i] + Ts[i+1])/2 - mint)/(maxt - mint)  # ratio of the node tension in relation to the max and min tension
                    cmap_obj = cm.get_cmap(cmap_tension)    # create a cmap object based on the desired colormap
                    rgba = cmap_obj(color_ratio)    # return the rbga values of the colormap of where the node tension is
                    linebit.append(ax.plot(Xs[i:i+2], Ys[i:i+2], Zs[i:i+2], color=rgba, zorder=100))
            else:
                linebit.append(ax.plot(Xs, Ys, Zs, color=color, lw=lw, zorder=100))
            
            if shadow:
                ax.plot(Xs, Ys, np.zeros_like(Xs)-self.sys.depth, color=[0.5, 0.5, 0.5, 0.2], lw=lw, zorder = 1.5) # draw shadow
            
            if endpoints == True:
                linebit.append(ax.scatter([Xs[0], Xs[-1]], [Ys[0], Ys[-1]], [Zs[0], Zs[-1]], color = color))
                
            # drawing water velocity vectors (not for Rods for now) <<< should handle this better (like in getLineCoords) <<<
            ts = self.getTimestep(Time)
            Ux = self.Ux[ts,:]
            Uy = self.Uy[ts,:]
            Uz = self.Uz[ts,:]      
            self.Ubits = ax.quiver(Xs, Ys, Zs, Ux, Uy, Uz)  # make quiver plot and save handle to line object
                
            
        self.linebit = linebit # can we store this internally?
        
        self.X = np.array([Xs, Ys, Zs])
        
            
        return linebit
    
    def redrawLine(self, Time, colortension=False, cmap_tension='rainbow'):  #, linebit):
        '''Update 3D line drawing based on instantaneous position'''
        
        linebit = self.linebit
        
        if self.isRod > 0:
            
            Xs, Ys, Zs, Ts = self.getLineCoords(Time)
            
            for i in range(int(len(Xs)/2-1)):
                        
                linebit[3*i  ][0].set_data(Xs[2*i:2*i+2],Ys[2*i:2*i+2])    # side edges (x and y coordinates)
                linebit[3*i  ][0].set_3d_properties(Zs[2*i:2*i+2])         #            (z coordinates)             
                linebit[3*i+1][0].set_data(Xs[[2*i,2*i+2]],Ys[[2*i,2*i+2]])           # end A edges
                linebit[3*i+1][0].set_3d_properties(Zs[[2*i,2*i+2]])                    
                linebit[3*i+2][0].set_data(Xs[[2*i+1,2*i+3]],Ys[[2*i+1,2*i+3]])   # end B edges
                linebit[3*i+2][0].set_3d_properties(Zs[[2*i+1,2*i+3]])
        
        # drawing lines...
        else:
        
            Xs, Ys, Zs, Ts = self.getLineCoords(Time)
            
            if colortension:
                self.rA = np.array([Xs[0], Ys[0], Zs[0]])       # update the line ends based on the MoorDyn data
                self.rB = np.array([Xs[-1], Ys[-1], Zs[-1]])
                tensions = self.getLineTens()                   # get the tensions of the line calculated quasi-statically
                maxt = np.max(tensions); mint = np.min(tensions)
                cmap_obj = cm.get_cmap(cmap_tension)               # create the colormap object
                
                for i in range(len(Xs)-1):  # for each node in the line, find the relative tension of the segment based on the max and min tensions
                    color_ratio = ((tensions[i] + tensions[i+1])/2 - mint)/(maxt - mint)
                    rgba = cmap_obj(color_ratio)
                    linebit[i][0]._color = rgba         # set the color of the segment to a new color based on its updated tension
                    linebit[i][0].set_data(Xs[i:i+2],Ys[i:i+2])     # set the x and y coordinates
                    linebit[i][0].set_3d_properties(Zs[i:i+2])      # set the z coorindates
            
            else:
                linebit[0][0].set_data(Xs,Ys)    # (x and y coordinates)
                linebit[0][0].set_3d_properties(Zs)         # (z coordinates) 
                    
            
        
            # drawing water velocity vectors: IN PROGRESS
            ts = self.getTimestep(Time)
            Ux = self.Ux[ts,:]
            Uy = self.Uy[ts,:]
            Uz = self.Uz[ts,:]                  
            #segments = quiver_data_to_segments(Xs, Ys, Zs, Ux, Uy, Uz, scale=2)
            #self.Ubits.set_segments(segments)
        
        return linebit  

class Body():  # from MoorPy # still required the add rod function from older versions of MoorPy. Classes are here in case moorpy class no longer work. 
    '''A class for any object in the mooring system that will have its own reference frame'''
    
    def __init__(self, mooringSys, num, type, r6):
        '''Initialize Body attributes

        Parameters
        ----------
        mooringSys : system object
            The system object that contains the body object
        num : int
            indentifier number
        type : int
            the body type: 0 free to move, 1 fixed, -1 coupled externally
        r6 : array
            6DOF position and orientation vector [m, rad]
        
        Returns
        -------
        None.

        '''
    
        self.sys    = mooringSys       # store a reference to the overall mooring system (instance of System class)
        
        self.number = num
        self.type   = type                          # 0 free to move, or -1 coupled externally
        self.r6     = np.array(r6, dtype=np.float_)     # 6DOF position and orientation vector [m, rad]
        
        self.attachedP   = []          # ID numbers of any Points attached to the Body
        self.rPointRel   = []          # coordinates of each attached Point relative to the Body reference frame
        
        self.attachedR   = []          # ID numbers of any Rods attached to the Body (not yet implemented)
        self.r6RodRel   = []           # coordinates and unit vector of each attached Rod relative to the Body reference frame
        
        self.R = np.eye(3)             # body orientation rotation matrix
         
    def attachPoint(self, pointID, rAttach):
        '''Adds a Point to the Body, at the specified relative position on the body.
        
        Parameters
        ----------
        pointID : int
            The identifier ID number of a point
        rAttach : array
            The position of the point relative to the body's frame [m]

        Returns
        -------
        None.

        '''
    
        self.attachedP.append(pointID)
        self.rPointRel.append(np.array(rAttach))

    def attachRod(self, rodID, endCoords):
        '''Adds a Point to the Body, at the specified relative position on the body.
        
        Parameters
        ----------
        rodID : int
            The identifier ID number of a point
        endCoords : array
            The position of the Rods two ends relative to the body reference frame [m]

        Returns
        -------
        None.

        '''
    
        k = (endCoords[3:]-endCoords[:3])/np.linalg.norm(endCoords[3:]-endCoords[:3])
    
        self.attachedR.append(rodID)
        self.r6RodRel.append(np.hstack([ endCoords[:3], k]))
        
class Point(): # from MoorPy
    '''A class for any object in the mooring system that can be described by three translational coorindates'''
    
    def __init__(self, mooringSys, num, type, r):
        '''Initialize Point attributes

        Parameters
        ----------
        mooringSys : system object
            The system object that contains the point object
        num : int
            indentifier number
        type : int
            the point type: 0 free to move, 1 fixed, -1 coupled externally
        r : array
            x,y,z coorindate position vector [m].
        m : float, optional
            mass [kg]. The default is 0.
        v : float, optional
            volume [m^3]. The default is 0.
        fExt : array, optional
            applied external force vector in global orientation (not including weight/buoyancy). The default is np.zeros(3).
        DOFs: list
            list of which coordinate directions are DOFs for this point (default 0,1,2=x,y,z). E.g. set [2] for vertical motion only.
        
        Returns
        -------
        None.

        '''
    
        self.sys    = mooringSys        # store a reference to the overall mooring system (instance of System class)
    
        self.number = num
        self.type = type                # 1: fixed/attached to something, 0 free to move, or -1 coupled externally
        self.r = np.array(r, dtype=np.float_)
        
        self.attached     = []         # ID numbers of any Lines attached to the Point
        self.attachedEndB = []         # specifies which end of the line is attached (1: end B, 0: end A)

    def attachLine(self, lineID, endB):
        '''Adds a Line end to the Point

        Parameters
        ----------
        lineID : int
            The identifier ID number of a line
        endB : boolean
            Determines which end of the line is attached to the point

        Returns
        -------
        None.

        '''

        self.attached.append(lineID)  
        self.attachedEndB.append(endB)

# Other classes and functions for driving and plotting
class load_infile():
    # Built from system class and contained functions in MoorPy dev branch

    def __init__(self, in_dirname = "", out_dirname = "", rootname = "", extension = "", fig_options = {}, tMax = 0, printing = 1):
        
        self.printing = printing # verbosity of printed statements to terminal. Recommended is 1. 0 disables all printing.

        self.in_dirname = in_dirname
        self.out_dirname = out_dirname
        self.rootname = rootname
        self.extension = extension
        self.in_file = str(in_dirname+rootname+extension)

        # lists to hold mooring system objects
        self.bodyList = []
        self.rodList = []
        self.pointList = []
        self.lineList = []
        self.lineTypes = {}
        self.rodTypes = {}

        self.fig_options = fig_options
        
        self.MDoptions = {} # dictionary that can hold any MoorDyn options read in from an input file, so they can be saved in a new MD file if need be
        self.outputList = [] # Output channels for unload

        self.tMax = tMax

        # read in data from an input file if a filename was provided
        if len(self.in_file) > 0:
            self.load()

            # For plotting later
            self.depth = float(self.MDoptions["WtrDpth"])

            # So that timeseries data is not loaded multiple times by plot_start_end and plot_animation
            self.md_branch_old = ""

        else:
            if (self.printing > 0):
                print("MD_Driver: Warning: input file empty, water depth unknown for plotting ouputs")

    def load(self):
        '''Loads a MoorPy System from a MoorDyn-style input file

        Parameters
        ----------
        filename : string
            the file name of a MoorDyn-style input file.

        Raises
        ------
        ValueError
            DESCRIPTION.

        Returns
        -------
        None.

        '''
        
        # create/empty the lists to start with

        self.lineTypes = {}  # create empty dictionary for line types
        self.rodTypes = {}  # create empty dictionary for line types

        # ensure the mooring system's object lists are empty before adding to them
        self.bodyList = []
        self.rodList  = []
        self.pointList= []
        self.lineList = []
        
        # the ground body (number 0, type 1[fixed]) never moves but is the parent of all anchored things
        self.groundBody = Body(self, 0, 1, np.zeros(6)) 

        # number of coupled objects, for determining vector size in running MoorDyn
        self.num_coupled = 0 
        
        # figure out if it's a YAML file or MoorDyn-style file based on the extension, then open and process
        if (self.printing > 0):
            print('MD_Driver: Loading '+self.in_file)

        # assuming normal form
        f = open(self.in_file, 'r')

        # read in the data
        for line in f:          # loop through each line in the file

            # get line type property sets
            if line.count('---') > 0 and (line.upper().count('LINE DICTIONARY') > 0 or line.upper().count('LINE TYPES') > 0):
                line = next(f) # skip this header line, plus channel names and units lines
                line = next(f)
                line = next(f)
                while line.count('---') == 0:
                    entries = line.split()  # entries: TypeName   Diam    Mass/m     EA     BA/-zeta    EI         Cd     Ca     CdAx    CaAx
                    
                    type_string = entries[0]
                    d    = float(entries[1])
                    lineType = dict(name=type_string, d_vol=d)  # make dictionary for this rod type

                    if len(entries) >= 10: # read in other elasticity and hydro coefficients as well if enough columns are provided
                        lineType['material'] = type_string
                    else:
                        if (self.printing > 0):
                            print("MD_Driver: WARNING: line material not read")
                    
                    if type_string in self.lineTypes:                         # if there is already a line type with this name
                        self.lineTypes[type_string].update(lineType)          # update the existing dictionary values rather than overwriting with a new dictionary
                    else:
                        self.lineTypes[type_string] = lineType
                    
                    line = next(f)
                           
            # get rod type property sets
            if line.count('---') > 0 and (line.upper().count('ROD DICTIONARY') > 0 or line.upper().count('ROD TYPES') > 0):
                line = next(f) # skip this header line, plus channel names and units lines
                line = next(f)
                line = next(f)
                while line.count('---') == 0:
                    entries = line.split()  # entries: TypeName      Diam     Mass/m    Cd     Ca      CdEnd    CaEnd
                    
                    type_string = entries[0]
                    d    = float(entries[1])
                    
                    rodType = dict(name=type_string, d_vol=d)  # make dictionary for this rod type
                                        
                    if type_string in self.rodTypes:                        # if there is already a rod type with this name
                        self.rodTypes[type_string].update(rodType)          # update the existing dictionary values rather than overwriting with a new dictionary
                    else:
                        self.rodTypes[type_string] = rodType
                    
                    line = next(f)
                    
            # get properties of each Body
            if line.count('---') > 0 and (line.upper().count('BODIES') > 0 or line.upper().count('BODY LIST') > 0 or line.upper().count('BODY PROPERTIES') > 0):
                line = next(f) # skip this header line, plus channel names and units lines
                line = next(f)
                line = next(f)
                while line.count('---') == 0:
                    entries = line.split()  # entries: ID   Attachment  X0  Y0  Z0  r0  p0  y0    M  CG*  I*    V  CdA*  Ca*            
                    num = int(entries[0])
                    entry0 = entries[1].lower()                         
                    
                    if ("fair" in entry0) or ("coupled" in entry0) or ("ves" in entry0):       # coupled case
                        self.num_coupled += 1
                        bodyType = -1                        
                    elif ("con" in entry0) or ("free" in entry0):                              # free case
                        bodyType = 0
                    else:                                                                      # for now assuming unlabeled free case
                        bodyType = 0
                        # if we detected there were unrecognized chars here, could: raise ValueError(f"Body type not recognized for Body {num}")
                    
                    r6  = np.array(entries[2:8], dtype=float)   # initial position and orientation [m, rad]
                    r6[3:] = r6[3:]*np.pi/180.0                 # convert from deg to rad
                                                                
                    # add the body
                    self.bodyList.append(Body(self, num, bodyType, r6) )
                                
                    line = next(f)
                    
            # get properties of each rod
            if line.count('---') > 0 and (line.upper().count('RODS') > 0 or line.upper().count('ROD LIST') > 0 or line.upper().count('ROD PROPERTIES') > 0):
                line = next(f) # skip this header line, plus channel names and units lines
                line = next(f)
                line = next(f)
                while line.count('---') == 0:
                    entries = line.split()  # entries: RodID  RodType  Attachment  Xa   Ya   Za   Xb   Yb   Zb  NumSegs  Flags/Outputs
                    num = int(entries[0])
                    rodType = self.rodTypes[entries[1]]
                    attachment = entries[2].lower()
                    if ('coupled' in attachment) or ('Coupled' in attachment) or ('vessel' in attachment) or ('Vessel' in attachment):
                        self.num_coupled += 1
                        coupled = 1
                    else:
                        coupled = 0
                    rA = np.array(entries[3:6], dtype=float)
                    rB = np.array(entries[6:9], dtype=float)
                    nSegs = int(entries[9])
                    
                    if nSegs==0:       # this is the zero-length special case
                        lUnstr = 0
                        self.rodList.append(Line(self, num, lUnstr, rodType, nSegs=nSegs, isRod=1, coupled=coupled, printing = self.printing) )
                    else:
                        lUnstr = np.linalg.norm(rB-rA)
                        self.rodList.append(Line(self, num, lUnstr, rodType, nSegs=nSegs, isRod=1, coupled=coupled, printing = self.printing) )
                        
                        if ("body" in attachment) or ("turbine" in attachment):
                            # attach to body here
                            BodyID = int("".join(filter(str.isdigit, attachment)))
                            if len(self.bodyList) < BodyID:
                                self.bodyList.append(Body(self, 1, 0, np.zeros(6)))
                                
                            self.bodyList[BodyID-1].attachRod(num, np.hstack([rA,rB]))
                            
                        else:
                            self.rodList[-1].rA = rA
                            self.rodList[-1].rB = rB 
                        
                    line = next(f)
                    
            
            # get properties of each Point
            if line.count('---') > 0 and (line.upper().count('POINTS') > 0 or line.upper().count('POINT LIST') > 0 or line.upper().count('POINT PROPERTIES') > 0 or line.upper().count('CONNECTION PROPERTIES') > 0 or line.upper().count('NODE PROPERTIES') > 0):
                line = next(f) # skip this header line, plus channel names and units lines
                line = next(f)
                line = next(f)
                while line.count('---') == 0:
                    entries = line.split()         # entries:  ID   Attachment  X       Y     Z      Mass   Volume  CdA    Ca
                    entry0 = entries[0].lower()          
                    entry1 = entries[1].lower() 
                    
                    num = np.int_("".join(c for c in entry0 if not c.isalpha()))  # remove alpha characters to identify Point #
                    
                    if ("anch" in entry1) or ("fix" in entry1):
                        pointType = 1
                        # attach to ground body for ease of identifying anchors
                        self.groundBody.attachPoint(num,entries[2:5]) 
                        
                    elif ("body" in entry1) or ("turbine" in entry1):
                        pointType = 1
                        # attach to body here
                        BodyID = int("".join(filter(str.isdigit, entry1)))
                        if len(self.bodyList) < BodyID:
                            self.bodyList.append(Body(self, 1, 0, np.zeros(6)))
                        
                        rRel = np.array(entries[2:5], dtype=float)
                        self.bodyList[BodyID-1].attachPoint(num, rRel)
                        
                    elif ("fair" in entry1) or ("ves" in entry1) or ("couple" in entry1):
                        # for coupled point type, just set it up that same way in MoorPy (attachment to a body not needed, right?)
                        pointType = -1     
                        self.num_coupled += 1                       
                       
                    elif ("con" in entry1) or ("free" in entry1) or ("point" in entry1):
                        pointType = 0
                    else:
                        if (self.printing > 0):
                            print("MD_Driver: WARNING: Point type not recognized")
                    
                    if 'seabed' in entries[4]:
                        entries[4] = -self.depth
                    r = np.array(entries[2:5], dtype=float)
                    self.pointList.append(Point(self, num, pointType, r) )
                    line = next(f)
                    
            # get properties of each line
            if line.count('---') > 0 and (line.upper().count('LINES') > 0 or line.upper().count('LINE LIST') > 0 or line.upper().count('LINE PROPERTIES') > 0):
                line = next(f) # skip this header line, plus channel names and units lines
                line = next(f)
                line = next(f)
                while line.count('---') == 0:
                    entries = line.split()  # entries: ID  LineType  AttachA  AttachB  UnstrLen  NumSegs   Outputs
                                            
                    num    = np.int_(entries[0])
                    lUnstr = np.float_(entries[4])
                    lineType = self.lineTypes[entries[1]]
                    nSegs  = np.int_(entries[5])         
                    
                    self.lineList.append(Line(self, num, lUnstr, lineType, nSegs=nSegs, printing = self.printing)) #attachments = [int(entries[4]), int(entries[5])]) )
                    
                    # attach end A
                    numA = int("".join(filter(str.isdigit, entries[2])))  # get number from the attachA string
                    if entries[2][0] in ['r','R']:    # if id starts with an "R" or "Rod"  
                        if numA <= len(self.rodList) and numA > 0:
                            if entries[2][-1] in ['a','A']:
                                self.rodList[numA-1].attachLine(num, 0)  # add line (end A, denoted by 0) to rod >>end A, denoted by 0<<
                            elif entries[2][-1] in ['b','B']: 
                                self.rodList[numA-1].attachLine(num, 0)  # add line (end A, denoted by 0) to rod >>end B, denoted by 1<<
                            else:
                                raise ValueError(f"Rod end (A or B) must be specified for line {num} end A attachment. Input was: {entries[2]}")
                        else:
                            raise ValueError(f"Rod ID ({numA}) out of bounds for line {num} end A attachment.") 
                    
                    else:     # if J starts with a "C" or "Con" or goes straight ot the number then it's attached to a Connection
                        if numA <= len(self.pointList) and numA > 0:  
                            self.pointList[numA-1].attachLine(num, 0)  # add line (end A, denoted by 0) to Point
                        else:
                            raise ValueError(f"Point ID ({numA}) out of bounds for line {num} end A attachment.") 

                    # attach end B
                    numB = int("".join(filter(str.isdigit, entries[3])))  # get number from the attachA string
                    if entries[3][0] in ['r','R']:    # if id starts with an "R" or "Rod"  
                        if numB <= len(self.rodList) and numB > 0:
                            if entries[3][-1] in ['a','A']:
                                self.rodList[numB-1].attachLine(num, 1)  # add line (end B, denoted by 1) to rod >>end A, denoted by 0<<
                            elif entries[3][-1] in ['b','B']: 
                                self.rodList[numB-1].attachLine(num, 1)  # add line (end B, denoted by 1) to rod >>end B, denoted by 1<<
                            else:
                                raise ValueError(f"Rod end (A or B) must be specified for line {num} end B attachment. Input was: {entries[2]}")
                        else:
                            raise ValueError(f"Rod ID ({numB}) out of bounds for line {num} end B attachment.") 
                    
                    else:     # if J starts with a "C" or "Con" or goes straight ot the number then it's attached to a Connection
                        if numB <= len(self.pointList) and numB > 0:  
                            self.pointList[numB-1].attachLine(num, 1)  # add line (end B, denoted by 1) to Point
                        else:
                            raise ValueError(f"Point ID ({numB}) out of bounds for line {num} end B attachment.") 

                    line = next(f)  # advance to the next line

            # get options entries
            if line.count('---') > 0 and "options" in line.lower():
                line = next(f) # skip this header line
                
                while line.count('---') == 0:
                    entries = line.split()       
                    entry0 = entries[0] #.lower() 
                    entry1 = entries[1] #.lower() 
                    
                    # also store a dict of all parameters that can be regurgitated during an unload
                    self.MDoptions[entry1] = entry0
                    
                    line = next(f)
            if  line.count('---') > 0 and ("outputs" or "output") in line.lower():
                line = next(f) # skip this header line
            
                while line.count('---') == 0: 
                    self.outputList.append(line)
                    line = next(f)

        f.close()  # close data file
        if (self.printing > 0):
            print(f"Mooring input file '{self.in_file}' loaded successfully.")

    def unload(self, fileName, flag='p', outputList = []):

        # Does not work for rods. Currently used to build v1 file from MD v2 file

        '''Builds MD version 1 file from MD version 2 infile

        Parameters
        ----------
        fileName : string
            file name of output file to hold MoorPy System.
        flag:
            LineOutputs flag to be added
        outputList : list of strings, optional
            Optional list of additional requested output channels

        Returns
        -------
        None.

        '''
        #For version MoorDyn v1

        #Collection of default values, each can be customized when the method is called
        
        # Set up the dictionary that will be used to write the OPTIONS section
        # MDoptionsDict = dict(dtM=0.001, kb=3.0e6, cb=3.0e5, TmaxIC=60)        # start by setting some key default values
        # # Other available options: Echo=False, dtIC=2, CdScaleIC=10, threshIC=0.01
        # MDoptionsDict = self.MDoptions                                 # update the dict with any settings saved from an input file

        # Some default settings to fill in if coefficients aren't set
        lineTypeDefaults = {}        
        
        # Figure out mooring line attachments (Create a ix2 array of connection points from a list of m points)
        connection_points = np.empty([len(self.lineList),2])                   #First column is Anchor Node, second is Fairlead node
        for point_ind,point in enumerate(self.pointList,start = 1):                    #Loop through all the points
            for (line,line_pos) in zip(point.attached,point.attachedEndB):          #Loop through all the lines #s connected to this point
                if line_pos == 0:                                                       #If the A side of this line is connected to the point
                    connection_points[line -1,0] = point_ind                                #Save as as an Anchor Node
                elif line_pos == 1:                                                     #If the B side of this line is connected to the point
                    connection_points[line -1,1] = point_ind                                #Save as a Fairlead node
        
        #Outputs List
        Outputs = []
        
        if (self.printing > 0):
            print('MD_Driver: Writing '+fileName +' for MoorDyn v1')
        #Array to add strings to for each line of moordyn input file
        L = []                   
        
        # Generate text for the MoorDyn input file
        L.append('Output file generated by run_all_scripts')
            
        L.append("---------------------- LINE DICTIONARY -----------------------------------------------------")
        L.append("LineType         Diam     MassDenInAir   EA        BA/-zeta     Can    Cat    Cdn    Cdt")
        L.append("   (-)           (m)        (kg/m)       (N)       (Pa-s/-)     (-)    (-)    (-)    (-)")

        for key, lineType in self.lineTypes.items(): 
            di = lineTypeDefaults.copy()  # start with a new dictionary of just the defaults
            di.update(lineType)           # then copy in the lineType's existing values
            L.append("{:<12} {:7.4f} {:8.2f}  {:7.3e} {:7.3e}  {:<7.3f} {:<7.3f} {:<7.2f} {:<7.2f}".format(
                    key, di['d_vol'], di['m'], di['EA'], di['BA'], di['Ca'], di['CaAx'], di['Cd'], di['CdAx']))
        
        L.append("---------------------- NODE PROPERTIES ---------------------------------------------------------")
        L.append("Node    Type         X        Y        Z        M      V      FX     FY     FZ    CdA    CA ")
        L.append("(-)     (-)         (m)      (m)      (m)      (kg)   (m^3)  (kN)   (kN)   (kN)   (m^2)  (-)")
        
        for point in self.pointList:
            point_pos = point.r             # get point position in global reference frame to start with
            if point.type == 1:             # point is fixed or attached (anch, body, fix)
                point_type = 'Fixed'
                
                #Check if the point is attached to body
                for body in self.bodyList:
                    for attached_Point in body.attachedP:
                        
                        if attached_Point == point.number:
                            point_type = "Vessel"
                            point_pos = body.rPointRel[body.attachedP.index(attached_Point)]   # get point position in the body reference frame
                
            elif point.type == 0:           # point is coupled externally (con, free)
                point_type = 'Connect'
                    
            elif point.type == -1:          # point is free to move (fair, ves)
                point_type = 'Vessel'
            
            L.append("{:<4d} {:9} {:8.2f} {:8.2f} {:8.2f} {:9.2f} {:6.2f} {:6.2f} {:6.2f} {:6.2f} {:6.2f} {:6.2f}".format(
                        point.number,point_type, point_pos[0],point_pos[1],point_pos[2], point.m, point.v, 0, 0, 0, point.CdA, point.Ca))
            
        L.append("---------------------- LINE PROPERTIES -----------------------------------------------------")
        L.append("Line      LineType   UnstrLen  NumSegs  NodeAnch  NodeFair  Flags/Outputs")
        L.append("(-)         (-)       (m)        (-)      (-)       (-)         (-)")

        for i,line in enumerate(self.lineList):
            L.append("{:<4d} {:<15} {:8.3f} {:5d} {:7d} {:8d}      {}"
                    .format(line.number, line.type['name'], line.L, line.nNodes-1, int(connection_points[i,0]), int(connection_points[i,1]), flag))

        L.append("---------------------- SOLVER OPTIONS ----------------------------------------")

        for key, val in self.MDoptions.items():
            L.append(f"{val:<15}  {key}")
        
        L.append("--------------------------- OUTPUTS --------------------------------------------")
        
        Outputs = Outputs+outputList   # add any user-specified outputs passed to unload
        
        for Output in Outputs:
            L.append(Output)
        #L.append("END")
            
        L.append('--------------------- need this line ------------------')
        
        #Write the text file
        with open(fileName, 'w') as out:
            for x in range(len(L)):
                out.write(L[x])
                out.write('\n')
        
        if (self.printing > 0):
            print('MD_Driver: Successfully written '+fileName +' input file for MoorDyn v1')
       
    def v1_build(self, outfile  = "Mooring/lines.txt", flag='p'):
        # read in data from an input file if a filename was provided
        
        if os.path.exists("Mooring/lines.txt"): #protect from overwriting
            os.system("mv Mooring/lines.txt Mooring/lines_archived.txt")
            if (self.printing > 1):
                print("MD_Driver: Mooring/lines.txt moved to Mooring/lines_archived.txt to protect from overwriting.")
                print("MD_Driver: Mooring/lines_archived.txt will be overwritten next run of run_all_scripts.py")
        
        if not os.path.exists("Mooring/"):
                os.mkdir("Mooring/")

        self.unload(outfile, flag = flag, outputList = self.outputList)  
   
    def plot(self, ax=None, bounds='default', rbound=0, color=None, **kwargs):
        '''Plots the mooring system objects in their current positions
        Parameters
        ----------
        bounds : string, optional
            signifier for the type of bounds desired in the plot. The default is "default".
        ax : axes, optional
            Plot on an existing set of axes
        color : string, optional
            Some way to control the color of the plot ... TBD <<<
        hidebox : bool, optional
            If true, hides the axes and box so just the plotted lines are visible.
        rbound : float, optional
            A bound to be placed on each axis of the plot. If 0, the bounds will be the max values on each axis. The default is 0.
        title : string, optional
            A title of the plot. The default is "".
        linelabels : bool, optional
            Adds line numbers to plot in text. Default is False.
        pointlabels: bool, optional
            Adds point numbers to plot in text. Default is False.
        endpoints: bool, optional
            Adds visible end points to lines. Default is False.
        bathymetry: bool, optional
            Creates a bathymetry map of the seabed based on an input file. Default is False.
            
        Returns
        -------
        fig : figure object
            To hold the axes of the plot
        ax: axis object
            To hold the points and drawing of the plot
            
        '''
        
        # kwargs that can be used for plot or plot2d
        title           = kwargs.get('title'          , ""        )     # optional title for the plot
        time            = kwargs.get("time"           , 0         )     # the time in seconds of when you want to plot
        linelabels      = kwargs.get('linelabels'     , False     )     # toggle to include line number labels in the plot
        pointlabels     = kwargs.get('pointlabels'    , False     )     # toggle to include point number labels in the plot
        draw_body       = kwargs.get("draw_body"      , True      )     # toggle to draw the Bodies or not
        draw_anchors    = kwargs.get('draw_anchors'   , False     )     # toggle to draw the anchors of the mooring system or not  
        bathymetry      = kwargs.get("bathymetry"     , False     )     # toggle (and string) to include bathymetry or not. Can do full map based on text file, or simple squares
        cmap_bath       = kwargs.get("cmap"           , 'ocean'   )     # matplotlib colormap specification
        alpha           = kwargs.get("opacity"        , 1.0       )     # the transparency of the bathymetry plot_surface
        rang            = kwargs.get('rang'           , 'hold'    )     # colorbar range: if range not used, set it as a placeholder, it will get adjusted later
        cbar_bath       = kwargs.get('cbar_bath'      , False     )     # toggle to include a colorbar for a plot or not
        colortension    = kwargs.get("colortension"   , False     )     # toggle to draw the mooring lines in colors based on node tensions
        cmap_tension    = kwargs.get('cmap_tension'   , 'rainbow' )     # the type of color spectrum desired for colortensions
        cbar_tension    = kwargs.get('cbar_tension'   , False     )     # toggle to include a colorbar of the tensions when colortension=True
        figsize         = kwargs.get('figsize'        , (6,4)     )     # the dimensions of the figure to be plotted
        # kwargs that are currently only used in plot
        hidebox         = kwargs.get('hidebox'        , False     )     # toggles whether to show the axes or not
        endpoints       = kwargs.get('endpoints'      , False     )     # toggle to include the line end points in the plot
        waterplane      = kwargs.get("waterplane"     , False     )     # option to plot water surface
        shadow          = kwargs.get("shadow"         , True      )     # toggle to draw the mooring line shadows or not
        cbar_bath_size  = kwargs.get('colorbar_size'  , 1.0       )     # the scale of the colorbar. Not the same as aspect. Aspect adjusts proportions
        # bound kwargs
        xbounds         = kwargs.get('xbounds'        , None      )     # the bounds of the x-axis. The midpoint of these bounds determines the origin point of orientation of the plot
        ybounds         = kwargs.get('ybounds'        , None      )     # the bounds of the y-axis. The midpoint of these bounds determines the origin point of orientation of the plot
        zbounds         = kwargs.get('zbounds'        , None      )     # the bounds of the z-axis. The midpoint of these bounds determines the origin point of orientation of the plot
        
        # sort out bounds
        xs = []
        ys = []
        zs = [0, -self.depth]
        
        for point in self.pointList:
            xs.append(point.r[0])
            ys.append(point.r[1])
            zs.append(point.r[2])
            

        # if axes not passed in, make a new figure
        if ax == None:    
            fig = plt.figure(figsize=figsize)
            ax = plt.axes(projection='3d')
        else:
            fig = ax.get_figure()

        if color == None:
            if time == 0:
                color = "r"
            else:
                color = "b"
        
        # set bounds
        if rbound==0:
            if len(xs) > 0:
                rbound = max([max(xs), max(ys), -min(xs), -min(ys)]) # this is the most extreme coordinate
            else:
                rbound = self.depth
                
        # set the DATA bounds on the axis
        if bounds=='default':
            ax.set_zlim([-self.depth, 0])
        elif bounds=='rbound':   
            ax.set_xlim([-rbound,rbound])
            ax.set_ylim([-rbound,rbound])
            ax.set_zlim([-rbound, rbound])
        elif bounds=='mooring':
            ax.set_xlim([-rbound,0])
            ax.set_ylim([-rbound/2,rbound/2])
            ax.set_zlim([-self.depth, 0])
        
        # set the AXIS bounds on the axis (changing these bounds can change the perspective of the matplotlib figure)
        if (np.array([xbounds, ybounds, zbounds]) != None).any():
            ax.autoscale(enable=False,axis='both')
        if xbounds != None:
            ax.set_xbound(xbounds[0], xbounds[1])
        if ybounds != None:
            ax.set_ybound(ybounds[0], ybounds[1])
        if zbounds != None:
            ax.set_zbound(zbounds[0], zbounds[1])
        
        # draw things
        if draw_body:
            for body in self.bodyList:
                body.draw(ax)

        for rod in self.rodList:
            if len(self.rodList)==0:    # usually, there are no rods in the rodList
                pass
            else:
                if isinstance(rod, Line):
                    rod.drawLine(time, ax, color=color, shadow=shadow)
                #if isinstance(rod, Point):  # zero-length special case
                #    not plotting points for now
            
        
        if draw_anchors:
            for line in self.lineList:
                if line.zp[0,0]==-self.depth:
                    itime = int(time/line.dt)
                    r = [line.xp[itime,0], line.yp[itime,0], line.zp[itime,0]]
                    if color==None:
                        c='tab:blue'
                    else:
                        c=color
                    plt.plot(r[0], r[1], r[2], 'v', color=c, markersize=5)
        
        j = 0
        for line in self.lineList:
            if len(line.Tdata) == 0:
                pass
            else:
                j = j + 1
                if color==None and 'material' in line.type:
                    if 'chain' in line.type['material'] or 'Cadena80' in line.type['material']:
                        line.drawLine(time, ax, color=[.1, 0, 0], endpoints=endpoints, shadow=shadow, colortension=colortension, cmap_tension=cmap_tension)
                    elif 'rope' in line.type['material'] or 'polyester' in line.type['material'] or 'Dpoli169' in line.type['material']:
                        line.drawLine(time, ax, color=[.3,.5,.5], endpoints=endpoints, shadow=shadow, colortension=colortension, cmap_tension=cmap_tension)
                    elif 'nylon' in line.type['material']:
                        line.drawLine(time, ax, color=[.8,.8,.2], endpoints=endpoints, shadow=shadow, colortension=colortension, cmap_tension=cmap_tension)
                    else:
                        line.drawLine(time, ax, color=[0.5,0.5,0.5], endpoints=endpoints, shadow=shadow, colortension=colortension, cmap_tension=cmap_tension)
                else:
                    line.drawLine(time, ax, color=color, endpoints=endpoints, shadow=shadow, colortension=colortension, cmap_tension=cmap_tension)
                
                # Add line labels 
                if linelabels == True:
                    ax.text((line.rA[0]+line.rB[0])/2, (line.rA[1]+line.rB[1])/2, (line.rA[2]+line.rB[2])/2, j)
            
        if cbar_tension:
            maxten = max([max(line.getLineTens()) for line in self.lineList])   # find the max tension in the System
            minten = min([min(line.getLineTens()) for line in self.lineList])   # find the min tension in the System
            bounds = range(int(minten),int(maxten), int((maxten-minten)/256)) 
            norm = mpl.colors.BoundaryNorm(bounds, 256)     # set the bounds in a norm object, with 256 being the length of all colorbar strings
            fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap_tension), label='Tension (N)')  # add the colorbar
            fig.tight_layout()
            
        # Add point labels
        i = 0
        for point in self.pointList:
            points = []
            i = i + 1
            if pointlabels == True:
                ax.text(point.r[0], point.r[1], point.r[2], i, c = 'r')
            
            if bathymetry==True:     # if bathymetry is true, then make squares at each anchor point
                if point.attachedEndB[0] == 0 and point.r[2] < -400:
                    points.append([point.r[0]+250, point.r[1]+250, point.r[2]])
                    points.append([point.r[0]+250, point.r[1]-250, point.r[2]])
                    points.append([point.r[0]-250, point.r[1]-250, point.r[2]])
                    points.append([point.r[0]-250, point.r[1]+250, point.r[2]])
                    
                    Z = np.array(points)
                    verts = [[Z[0],Z[1],Z[2],Z[3]]]
                    ax.add_collection3d(Poly3DCollection(verts, facecolors='limegreen', linewidths=1, edgecolors='g', alpha=alpha))
            
        if isinstance(bathymetry, str):   # or, if it's a string, load in the bathymetry file

            # parse through the MoorDyn bathymetry file
            bathGrid_Xs, bathGrid_Ys, bathGrid = self.readBathymetryFile(bathymetry)
            if rang=='hold':
                rang = (np.min(-bathGrid), np.max(-bathGrid))
            '''
            # First method: plot nice 2D squares using Poly3DCollection
            nX = len(bathGrid_Xs)
            nY = len(bathGrid_Ys)
            # store a list of points in the grid
            Z = [[bathGrid_Xs[j],bathGrid_Ys[i],-bathGrid[i,j]] for i in range(nY) for j in range(nX)]
            # plot every square in the grid (e.g. 16 point grid yields 9 squares)
            verts = []
            for i in range(nY-1):
                for j in range(nX-1):
                    verts.append([Z[j+nX*i],Z[(j+1)+nX*i],Z[(j+1)+nX*(i+1)],Z[j+nX*(i+1)]])
                    ax.add_collection3d(Poly3DCollection(verts, facecolors='limegreen', linewidths=1, edgecolors='g', alpha=0.5))
                    verts = []
            '''
            # Second method: plot a 3D surface, plot_surface
            X, Y = np.meshgrid(bathGrid_Xs, bathGrid_Ys)
            
            bath = ax.plot_surface(X,Y,-bathGrid, cmap=cmap_bath, vmin=rang[0], vmax=rang[1], alpha=alpha)
            
            if cbar_bath_size!=1.0:    # make sure the colorbar is turned on just in case it isn't when the other colorbar inputs are used
                cbar_bath=True
            if cbar_bath:
                fig.colorbar(bath, shrink=cbar_bath_size, label='depth (m)')
        
        # draw water surface if requested
        if waterplane:
            waterXs = np.array([min(xs), max(xs)])
            waterYs = np.array([min(ys), max(ys)])
            waterX, waterY = np.meshgrid(waterXs, waterYs)
            ax.plot_surface(waterX, waterY, np.array([[-50,-50],[-50,-50]]), alpha=0.5)
    
        
        fig.suptitle(title)
        
        set_axes_equal(ax)
        
        ax.set_zticks([-self.depth, 0])  # set z ticks to just 0 and seabed
        
        if hidebox:
            ax.axis('off')
        
        return fig, ax  # return the figure and axis object in case it will be used later to update the plot

    def plot2d(self, Xuvec=[1,0,0], Yuvec=[0,0,1], ax=None, color=None, bounds='default', rbound=0, **kwargs):
        '''Makes a 2D plot of the mooring system objects in their current positions

        Parameters
        ----------
        Xuvec : list, optional
            plane at which the x-axis is desired. The default is [1,0,0].
        Yuvec : lsit, optional
            plane at which the y-axis is desired. The default is [0,0,1].            
        ax : axes, optional
            Plot on an existing set of axes
        color : string, optional
            Some way to control the color of the plot ... TBD <<<
        title : string, optional
            A title of the plot. The default is "".

        Returns
        -------
        fig : figure object
            To hold the axes of the plot
        ax: axis object
            To hold the points and drawing of the plot

        '''
        
        # kwargs that can be used for plot or plot2d
        title            = kwargs.get('title'           , ""        )   # optional title for the plot
        time             = kwargs.get("time"            , 0         )   # the time in seconds of when you want to plot
        linelabels       = kwargs.get('linelabels'      , False     )   # toggle to include line number labels in the plot
        pointlabels      = kwargs.get('pointlabels'     , False     )   # toggle to include point number labels in the plot
        draw_body        = kwargs.get("draw_body"       , False     )   # toggle to draw the Bodies or not
        draw_anchors     = kwargs.get('draw_anchors'    , False     )   # toggle to draw the anchors of the mooring system or not   
        bathymetry       = kwargs.get("bathymetry"      , False     )   # toggle (and string) to include bathymetry contours or not based on text file
        cmap_bath        = kwargs.get("cmap_bath"       , 'ocean'   )   # matplotlib colormap specification
        alpha            = kwargs.get("opacity"         , 1.0       )   # the transparency of the bathymetry plot_surface
        rang             = kwargs.get('rang'            , 'hold'    )   # colorbar range: if range not used, set it as a placeholder, it will get adjusted later
        cbar_bath        = kwargs.get('colorbar'        , False     )   # toggle to include a colorbar for a plot or not
        colortension     = kwargs.get("colortension"    , False     )   # toggle to draw the mooring lines in colors based on node tensions
        cmap_tension     = kwargs.get('cmap_tension'    , 'rainbow' )   # the type of color spectrum desired for colortensions
        cbar_tension     = kwargs.get('cbar_tension'    , False     )   # toggle to include a colorbar of the tensions when colortension=True
        figsize          = kwargs.get('figsize'         , (6,4)     )   # the dimensions of the figure to be plotted
        # kwargs that are currently only used in plot2d
        levels           = kwargs.get("levels"          , 7         )   # the number (or array) of levels in the contour plot
        cbar_bath_aspect = kwargs.get('cbar_bath_aspect', 20        )   # the proportion of the colorbar. Default is 20 height x 1 width
        cbar_bath_ticks  = kwargs.get('cbar_bath_ticks' , None      )   # the desired tick labels on the colorbar (can be an array)
        draw_fairlead    = kwargs.get('draw_fairlead'   , False     )   # toggle to draw large points for the fairleads
        
        # if axes not passed in, make a new figure
        if ax == None:
            fig, ax = plt.subplots(1,1, figsize=figsize)
        else:
            fig = ax.get_figure()

        if color == None:
            if time == 0:
                color = "r"
            else:
                color = "b"
        
        if draw_body:
            for body in self.bodyList:
                #body.draw(ax)
                r = body.r6[0:3]
                x = r[Xuvec.index(1)]
                y = r[Yuvec.index(1)]
                plt.plot(x, y, 'ko', markersize=5)
            
        for rod in self.rodList:
            if isinstance(rod, Line):
                rod.drawLine2d(time, ax, color=color, Xuvec=Xuvec, Yuvec=Yuvec)
            
        if draw_fairlead:
            for line in self.lineList:
                if line.number==1:
                    itime = int(time/line.dt)
                    r = [line.xp[itime,-1], line.yp[itime,-1], line.zp[itime,-1]]
                    x = r[Xuvec.index(1)]
                    y = r[Yuvec.index(1)]
                    if color==None:
                        c='tab:blue'
                    else:
                        c=color
                    plt.plot(x, y, 'o', color=c, markersize=5)
                         
        if draw_anchors:
            for line in self.lineList:
                if line.zp[0,0]==-self.depth:
                    itime = int(time/line.dt)
                    r = [line.xp[itime,0], line.yp[itime,0], line.zp[itime,0]]
                    x = r[Xuvec.index(1)]
                    y = r[Yuvec.index(1)]
                    if color==None:
                        c='tab:blue'
                    else:
                        c=color
                    plt.plot(x, y, 'v', color=c, markersize=5)
             
        j = 0
        for line in self.lineList:
            j = j + 1
            if color==None and 'material' in line.type:
                if 'chain' in line.type['material']:
                    line.drawLine2d(time, ax, color=[.1, 0, 0], Xuvec=Xuvec, Yuvec=Yuvec, colortension=colortension, cmap=cmap_tension)
                elif 'rope' in line.type['material'] or 'polyester' in line.type['material']:
                    line.drawLine2d(time, ax, color=[.3,.5,.5], Xuvec=Xuvec, Yuvec=Yuvec, colortension=colortension, cmap=cmap_tension)
                else:
                    line.drawLine2d(time, ax, color=[0.3,0.3,0.3], Xuvec=Xuvec, Yuvec=Yuvec, colortension=colortension, cmap=cmap_tension)
            else:
                line.drawLine2d(time, ax, color=color, Xuvec=Xuvec, Yuvec=Yuvec, colortension=colortension, cmap=cmap_tension)

            

            # Add Line labels
            if linelabels == True:
                xloc = np.dot([(line.rA[0]+line.rB[0])/2, (line.rA[1]+line.rB[1])/2, (line.rA[2]+line.rB[2])/2],Xuvec)
                yloc = np.dot([(line.rA[0]+line.rB[0])/2, (line.rA[1]+line.rB[1])/2, (line.rA[2]+line.rB[2])/2],Yuvec)
                ax.text(xloc,yloc,j)
        
        if cbar_tension:
            maxten = max([max(line.getLineTens()) for line in self.lineList])   # find the max tension in the System
            minten = min([min(line.getLineTens()) for line in self.lineList])   # find the min tension in the System
            bounds = range(int(minten),int(maxten), int((maxten-minten)/256)) 
            norm = mpl.colors.BoundaryNorm(bounds, 256)     # set the bounds in a norm object, with 256 being the length of all colorbar strings
            fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap_tension), label='Tension (N)')  # add the colorbar
            fig.tight_layout()
        
        # Add point labels
        i = 0 
        for point in self.pointList:
            i = i + 1
            if pointlabels == True:
                xloc = np.dot([point.r[0], point.r[1], point.r[2]], Xuvec)
                yloc = np.dot([point.r[0], point.r[1], point.r[2]], Yuvec)
                ax.text(xloc, yloc, i, c = 'r')
        
        if isinstance(bathymetry, str):   # or, if it's a string, load in the bathymetry file

            # parse through the MoorDyn bathymetry file
            bathGrid_Xs, bathGrid_Ys, bathGrid = self.readBathymetryFile(bathymetry)
            
            X, Y = np.meshgrid(bathGrid_Xs, bathGrid_Ys)
            Z = -bathGrid
            if rang=='hold':
                rang = (np.min(Z), np.max(Z))
            
            Xind = Xuvec.index(1); Yind = Yuvec.index(1); Zind = int(3-Xind-Yind)
            W = [X,Y,Z]
            
            # plot a contour profile of the bathymetry
            bath = ax.contourf(W[Xind],W[Yind],W[Zind], cmap=cmap_bath, levels=levels, alpha=alpha, vmin=rang[0], vmax=rang[1])
            
            if cbar_bath_aspect!=20 or cbar_bath_ticks!=None:    # make sure the colorbar is turned on just in case it isn't when the other colorbar inputs are used
                cbar_bath=True
            if cbar_bath:
                fig.colorbar(bath, label='depth (m)', aspect=cbar_bath_aspect, ticks=cbar_bath_ticks)
            
        
        ax.axis("scaled")
        ax.set_title(title)
        
        return fig, ax  # return the figure and axis object in case it will be used later to update the plot
        
    def updateCoords(self, tStep, label, dt): # animations in progress
        '''Update animation function. This gets called by animateLines every iteration of the animation and 
        redraws the lines and rods in their next positions.'''
        
        for rod in self.rodList:

            if isinstance(rod, Line):  # draw it if MoorPy is representing it as as Rod-Line object, and it's set to be shown
                rod.redrawLine(-tStep)
            
        for line in self.lineList:
            if len(line.Tdata) > 0:
                line.redrawLine(-tStep)
        
        if label != None:
            label.set_text(f'time={np.round(tStep*dt,1)}')
            
        return 

    def plot_start_end(self, plot2d = False, plot_all = False, color = None, ax= None, draw_body = False):
        
        tMax = self.lineList[0].Tdata[-1]
        tMin = self.lineList[0].Tdata[0]

        if plot_all:
            if plot2d:
                self.plot2d(ax=ax[0], bounds='rbound', rbound=0, color=color, time = tMin, draw_body = draw_body)
                self.plot2d(ax=ax[1], bounds='rbound', rbound=0, color=color, time = tMax-1, draw_body = draw_body)
            else:
                self.plot(ax=ax[0], bounds='default', rbound=0, color=color, time = tMin, draw_body = draw_body)
                self.plot(ax=ax[1], bounds='default', rbound=0, color=color, time = tMax-1, draw_body = draw_body)

            ax[0].set_title("tMin = {}".format(tMin))
            ax[1].set_title("tMax-1 = {}".format(tMax-1))

        else:
            if plot2d:
                self.plot2d(ax=ax, bounds='rbound', rbound=0, color = 'r', time = tMin, draw_body = draw_body)
                self.plot2d(ax=ax, bounds='rbound', rbound=0, color= 'b', time = tMax-1, draw_body = draw_body)
            else:
                self.plot(ax=ax, bounds='default', rbound=0, color= 'r', time = tMin, draw_body = draw_body)
                self.plot(ax=ax, bounds='default', rbound=0, color= 'b', time = tMax-1, draw_body = draw_body)

            ax.set_title(self.rootname+self.version)
        
    def plot_channel(self, ax, color, channelnum = 1):

        if len(self.data[:,0]) != (self.tMax/self.dtOut) - 1:
            data3 = self.dtOut_fix(self.data, len(self.channels))
        else: 
            data3 = self.data
    
        if self.version == 'Cpy':
            pattern = "-"
        elif self.version == 'C':
            pattern = "--"
        elif self.version == 'v1':
            pattern = "-."
        elif self.version == 'F':
            pattern = ":"
        else:
            pattern = "-"
        
        min = np.where(data3.astype(int)[:,0]==self.plot_tRange[0])[0][0] # TODO: this is a slow process
        max = np.where(data3.astype(int)[:,0]==self.plot_tRange[1])[0][0]

        ax.plot(data3[min:max,0], data3[min:max,channelnum], color = color, linestyle = pattern)

    def dtOut_fix (self, data, num_channels, tdata = None):
        
        time = np.arange(self.dtOut, self.tMax, self.dtOut) # is this used elsewhere? If so should be class variable
        if num_channels == 1:
            data1 = np.zeros(len(time))
            if tdata is None:
                if (self.printing > 0):
                    print('MD_Driver: ERROR: no time data for dtOut fix')
                return
            else:
                for i in range(1,num_channels):
                    data1[i] = np.interp(time, tdata, data[i])
        else: 
            data1 = np.zeros((len(time), num_channels))
            if tdata is None:
                data1[:,0] = time
                for i in range(1,num_channels):
                    data1[:,i] = np.interp(time, data[:,0], data[:,i])
            else:
                for i in range(0,num_channels):
                    data1[:,i] = np.interp(time, tdata, data[:,i])
        return data1
    
    def figures(self, plot_args = {}, versions = {}, tMax = 0):
        
        # options
        run_v1 = versions.get('run_v1', True)
        run_cpy = versions.get('run_cpy', True)
        run_c = versions.get('run_c', True)
        run_f = versions.get('run_f', True)

        display = plot_args.get('display', True)
        save = plot_args.get('save', False)
        plot_channels = plot_args.get('plot_channels', False)
        animate_all = plot_args.get('animate_all', False)
        animate_start_end = plot_args.get('animate_start_end', False)
        plot_individual_start_end = plot_args.get('plot_individual_start_end', False)
        plot_all_start_end = plot_args.get('plot_all_start_end', False)
        plot3d = plot_args.get('plot3d', False)
        plot2d = plot_args.get('plot2d', True)
        from_saved_runs = plot_args.get('from_saved_runs', True)
        outputs_dir = plot_args.get('outputs_dir' , 'outputs/')
        plot_tRange = plot_args.get('plot_tRange', None)
        draw_body = plot_args.get('draw_body', False)
        one_dataset = plot_args.get('one_dataset', False)

        self.tMax = int(tMax) # redundant
        self.dtC = float(self.MDoptions['dtM'])
        self.dtOut = float(self.MDoptions.get('dtOut', self.dtC))

        if plot_tRange == None or plot_tRange == 'All':
            plot_tRange = (0,self.tMax-1)
        self.plot_tRange = plot_tRange
        
        
        if from_saved_runs:
            if outputs_dir == None or outputs_dir == 'outputs/':
                outputs_dir = 'outputs/'
                self.out_dirname = outputs_dir+self.rootname+'_outputs/'
        elif outputs_dir == None:
            outputs_dir = 'MooringTest/'
        self.out_dirname = outputs_dir
        if (self.printing > 1):
            print('MD_Driver: Plotting from data in {}'.format(self.out_dirname))
        
        # Creating figures
        if plot_channels:
            pass # figure initalized when first channel list is read in
        if animate_all:
            fig4, ax4 = plt.subplots(1,1, subplot_kw = {'projection':'3d'})
        if animate_start_end:
            fig5, ax5 = plt.subplots(1,1, subplot_kw = {'projection':'3d'})
        if plot_individual_start_end:
            if plot2d:
                fig6, ax6 = plt.subplots(2,2)
            if plot3d:
                fig7, ax7 = plt.subplots(2,2, subplot_kw = {'projection':'3d'})
        if plot_all_start_end:
            if plot2d:
                fig8, ax8 = plt.subplots(2,1, sharex=True)
            if plot3d:
                fig9, ax9 = plt.subplots(1,2, subplot_kw = {'projection':'3d'})

        # Preparing  for loop
        if one_dataset:
            colors = ['red']
        else:
            version_list = ['Cpy', 'C', 'v1', 'F']
            colors = ['red', 'blue', 'orange', 'green']
            if not run_cpy:
                version_list.remove('Cpy')
                colors.remove('red')
            if not run_c:
                version_list.remove('C')
                colors.remove('blue')
            if not run_v1:
                version_list.remove('v1')
                colors.remove('orange')
            if not run_f:
                version_list.remove('F')
                colors.remove('green')

        j = 0 # loop index
        for version in version_list:
            self.version = version
            if len(self.rootname)==0:
                raise ValueError("The MoorDyn input root name of the MoorDyn output files need to be given.")
            if plot_all_start_end or plot_individual_start_end or animate_all or animate_start_end:
                for line in self.lineList:
                    if version == 'v1':
                        if one_dataset:
                            line.loadData(self.out_dirname, '', sep = '')
                        else:
                            line.loadData(self.out_dirname, 'Line', sep = '_')
                    else:
                        line.loadData(self.out_dirname, self.rootname+version, sep = '_') 
                for rod in self.rodList:
                    rod.loadData(self.out_dirname, self.rootname+version, sep = '_')
            if plot_channels:
                if version == 'v1':
                    if one_dataset:
                        self.data, self.ch, self.channels, self.units = read_mooring_file(self.out_dirname+'Lines.out', printing = self.printing)
                    else:
                        self.data, self.ch, self.channels, self.units = read_mooring_file(self.out_dirname+'Line_Lines.out', printing = self.printing)
                else:
                    self.data, self.ch, self.channels, self.units = read_mooring_file(self.out_dirname+self.rootname+version+'.out', printing = self.printing)

                if (j == 0): # intialize figure if first loop iteration
                    if len(self.channels) > 2:
                        fig3, ax3 = plt.subplots(len(self.channels)-1, 1, sharex=True)
                    else:
                        fig3, ax3 = plt.subplots(1,1)

                if len(self.channels) > 2:
                    for k, channel in enumerate(self.channels):
                        if k != 0:
                            self.plot_channel(ax3[k-1], colors[j], channelnum = k)
                else:
                    self.plot_channel(ax3, colors[j], channelnum = 1)
            if animate_all:
                anim = self.animateLines(ax = ax4, fig = fig4)
                plt.show()
            if animate_start_end:
                pass
            if plot_individual_start_end:
                if plot2d:
                    self.plot_start_end(plot2d = True, ax = ax6[j//2][int(j%2 != 0)], draw_body = draw_body)
                if plot3d:
                    self.plot_start_end(ax= ax7[j//2][int(j%2 != 0)], draw_body = draw_body)
            if plot_all_start_end:
                if plot2d:
                    self.plot_start_end(plot2d = True, plot_all = True, ax = ax8, color = colors[j], draw_body = draw_body)
                if plot3d:
                    self.plot_start_end(ax = ax9, plot_all = True, color = colors[j], draw_body = draw_body)
            j += 1

        if display or save:
            # Formatting 
            
            if plot_channels:
                fig3.suptitle(self.rootname+': Output channels')
                if len(self.channels) > 2:
                    for k, channel in enumerate(self.channels):
                        if k != 0:
                            ax3[k-1].legend(version_list, loc = 1)
                            ax3[k-1].set_ylabel(channel+' '+self.units[k])
                            ax3[k-1].set_xlim(plot_tRange)
                        if k == len(self.channels):
                            ax3[k-1].set_xlabel('Time (s)')
                else: 
                    ax3.legend(version_list, loc = 1)
                    ax3.set_ylabel(self.channels[1]+' '+self.units[1])
                    ax3.set_xlim(plot_tRange)
                    ax3.set_xlabel('Time (s)')
                fig3.tight_layout()

            if animate_all:
                pass
            if animate_start_end:
                pass
            if plot_individual_start_end:
                patches = [None]*2
                patches[0] = mpl.lines.Line2D([],[],color = 'r', label = 'tMin')
                patches[1] = mpl.lines.Line2D([],[],color = 'b', label = 'tMax')
                if plot2d:
                    fig6.suptitle("First and last timestep line shape:")
                    fig6.legend(handles = patches)
                    fig6.tight_layout()
                if plot3d:
                    fig7.suptitle("First and last timestep line shape:")
                    fig7.legend(handles = patches)
                    fig7.tight_layout()
            if plot_all_start_end:
                patches=[]
                for i, color in enumerate(colors):
                    patches.append(mpl.lines.Line2D([],[],color = color, label = version_list[i]))
                if plot2d:
                    fig8.suptitle("First and last timestep line shapes (all versions):")
                    fig8.legend(handles = patches)
                    ax8[0].set_ylabel('Depth (m)')
                    ax8[1].set_ylabel('Depth (m)')
                    fig8.supxlabel('Position (m)')
                    fig8.tight_layout()
                if plot3d:
                    fig9.suptitle("First and last timestep line shapes (all versions):")
                    fig9.legend(handles = patches)
                    fig9.tight_layout()

            if display: 
                plt.show()

            if save:
                if plot_channels:
                    fig3.savefig(self.rootname+'_tens.png', dpi = 300)
                if animate_all:
                    pass
                if animate_start_end:
                    pass
                if plot_individual_start_end:
                    if plot2d:
                        fig6.savefig(self.rootname+"_indiv2d.png", dpi = 300)
                    if plot3d:
                        fig7.savefig(self.rootname+"_indiv3d.png", dpi = 300)
                if plot_all_start_end:
                    if plot2d:
                        fig8.savefig(self.rootname+"_all2d.png", dpi = 300)
                    if plot3d:
                        fig9.savefig(self.rootname+"_all3d.png", dpi = 300)
                
                if not os.path.isdir(outputs_dir):
                    os.system('mkdir {}'.format(outputs_dir))
                if not os.path.isdir('{}/figures/'.format(outputs_dir)):
                    os.system('mkdir {}/figures/'.format(outputs_dir))
                if not os.path.isdir('{}/figures/{}'.format(outputs_dir, self.rootname)):
                    os.system('mkdir {}/figures/{}'.format(outputs_dir, self.rootname))
                os.system('mv {}*.png {}/figures/{}/'.format(self.rootname, outputs_dir, self.rootname))
                if (self.printing > 0):
                    print('MD_Driver: {}*.png saved to {}/figures/'.format(outputs_dir, self.rootname))
        else:
            if (self.printing > 1):
                print('MD_Driver: Warning: Display and save figures booleans are false')

class run_infile():

    def __init__(self, plot_args = {}, dynamics_args = {}, versions = {}):
        self.plot_args = plot_args
        self.dynamics_args = dynamics_args
        self.versions = versions
        
    def MDf_build(self):

        os.system("cp MD_fortran_input/MoorDyn.dvr MD_fortran_input/MoorDyn_archived.dvr")
        driverfile = "MD_fortran_input/MoorDyn.dvr"

        if self.num_coupled == 0:
            InputsMode = 0
        else:
            InputsMode = 1
        
        with open(driverfile, 'w') as myfile:     # open an input stream to the line data input file
            myfile.writelines(['MoorDyn driver input file \n'])
            myfile.writelines(['another comment line\n'])
            myfile.writelines(['---------------------- ENVIRONMENTAL CONDITIONS ------------------------------- \n'])
            myfile.writelines(['9.80665            Gravity          - Gravity (m/s^2) \n'])
            myfile.writelines(['{}             rhoW             - Water density (kg/m^3) \n'.format(self.WtrDnsty)])
            myfile.writelines(['{}              WtrDpth          - Water depth (m) \n'.format(self.WtrDpth)])
            myfile.writelines(['---------------------- MOORDYN ------------------------------------------------ \n'])
            myfile.writelines(['"{}"      MDInputFile      - Primary HydroDyn input file name (quoted string) \n'.format(os.path.abspath('MD_fortran_input/'+self.rootname+'F'+self.extension))])
            myfile.writelines(['"../MooringTest/F"            OutRootName      - The name which prefixes all HydroDyn generated files (quoted string) \n'])
            myfile.writelines(['{}                  TMax             - Number of time steps in the simulations (-) \n'.format(self.tMax)])
            myfile.writelines(['{}                 dtC              - TimeInterval for the simulation (sec) \n'.format(self.dtC)])
            myfile.writelines(['{}                   InputsMode       - MoorDyn coupled object inputs (0: all inputs are zero for every timestep (no coupled objects), 1: time-series inputs (coupled objects)) (switch) \n'.format(InputsMode)])
            myfile.writelines(['"/Users/rdavies/work/MoorDyn_ryan/testing/MD_fortran_input/PtfmMotions.dat"   InputsFile       - Filename for the MoorDyn inputs file for when InputsMod = 1 (quoted string) \n'])
            myfile.writelines(['0                   NumTurbines      - Number of wind turbines (-) [>=1 to use FAST.Farm mode. 0 to use OpenFAST mode.] \n'])
            myfile.writelines(['---------------------- Initial Positions -------------------------------------- \n'])
            myfile.writelines(['ref_X    ref_Y    surge_init   sway_init  heave_init  roll_init  pitch_init   yaw_init \n'])
            myfile.writelines(['(m)      (m)        (m)          (m)        (m)       (rad)       (rad)        (rad)         [followed by MAX(1,NumTurbines) rows of data] \n'])
            myfile.writelines(['0         0          0            0          0          0           0            0 \n'])
            myfile.writelines(['END of driver input file \n'])

    def get_positions(self):
        scalar = []
        if self.dof == 3:
            scalar_3dof = [1,1,1]
            for i in range(self.num_coupled):
                scalar.extend(scalar_3dof)
        elif self.dof == 6:
            scalar_6dof = [1., 1., 1., np.pi/180, np.pi/180, np.pi/180]  # for scaling platform position inputs. Note: file needs to be in units of deg
            for i in range(self.num_coupled):
                scalar.extend(scalar_6dof)

        outFileName = "MooringTest/ptfm_motions.dat"
        i=0  # file line number
        t_in = []
        Xp_in = []
        myfile2 = open(outFileName, 'r');     # open an input stream to the line data input file
        if myfile2:
            if (self.printing > 1):
                print(outFileName, " opened.") 
            for line2 in myfile2:
                # skip data in first line (header)
                if (i < 1):
                    i+=1
                    continue
                #  split line by tabs
                datarow = list(line2.split())
                
                if ((len(datarow) < 7) and (self.dof == 6)): 
                    if (self.printing > 0):
                        print("MD_Driver: Seems like we've hit a bad line or end of file. ")
                    break;                  # break if we're on a last empty line
                if ((len(datarow) < 4) and (self.dof == 3)): 
                    if (self.printing > 0):
                        print("MD_Driver: Seems like we've hit a bad line or end of file. ")
                    break;                  # break if we're on a last empty line
                
                t_in.append(float(datarow[0]))
                scaled_data = []			
                for j in range(self.dof*self.num_coupled):
                    scaled_data.append(float(datarow[j+1]) *scalar[j]) # add platform positions
                Xp_in.append(scaled_data)
                i += 1
        else:
            if (self.printing > 0):
                print("MD_Driver: ERROR: could not open ", outFileName)
            return

        myfile2.close()
        if (self.printing > 1):
            print("MD_Driver: Done reading ptfm_motions.dat. Last line read: ", i)

        Xp_in = np.array(Xp_in)

        # interpolator for platform positions: t_in is vector of time steps from position input file. xp_in is dof
        ts = 0
        self.xp = np.zeros((len(self.time),len(Xp_in[0])))
        for its in range(0, len(self.time)):

            t = its*self.dtC
            
            # interpolate platform positions from .out file data, and approximate velocities
            while ts < (len(t_in)-1):  # search through platform motion data time steps (from .out file)	
                if (t_in[ts+1] > t):				
                    frac = ( t - t_in[ts] )/( t_in[ts+1] - t_in[ts] )		# get interpolation fraction
                    for j in range(0, len(Xp_in[0])):
                        self.xp[its][j] = Xp_in[ts][j] + frac*( Xp_in[ts+1][j] - Xp_in[ts][j] ) # interpolate for each platform DOF
                    break
                ts += 1
        self.xdp = np.zeros((len(self.time),len(Xp_in[0])))
        xold = np.zeros(len(Xp_in[0]))
        # calculate velocities using finite difference
        for i in range(len(self.time)):
            self.xdp [i] = (self.xp[i] - xold)/self.dtC
            xold =  self.xp[i]
        
        return
        
    def sin (self):

        period = self.dynamics_args.get('period', 150)
        A = self.dynamics_args.get('Amplitude', 10)
        axis = self.dynamics_args.get('axis', 0)

        # axis 0 -> x, 1 -> y, 3 -> z
        self.xp = np.zeros((len(self.time),6))
        
        # Wave properties
        T = period / self.dtC
        omega = (2*np.pi)/T
        
        for i in range(len(self.time)):
            self.xp[i,axis] = A * np.sin(i*omega)

        self.xdp = np.zeros((len(self.time),6))
        xold = np.zeros(6)
        # calculate velocities using finite difference
        for i in range(len(self.time)):
            self.xdp [i] = (self.xp[i] - xold)/self.dtC
            xold =  self.xp[i]

    def load_dynamics(self):

        static = self.dynamics_args.get('static', False)
        sin = self.dynamics_args.get('sin', True)
        from_file = self.dynamics_args.get('from_file', False)

        # initializing
        self.time = np.arange(0, self.tMax, self.dtC)
        size = (len(self.time), self.vector_size)
        self.x = np.zeros(size, dtype = float)
        self.xd = np.zeros(size, dtype = float)
        if static:
            self.xdp = np.zeros(size)
            self.xp = np.zeros(size)
            for i in range(len(self.time)):
                self.x[i,:] = self.xi

        elif from_file:
            self.get_positions()
            for i in range(len(self.time)):
                if i == 0:
                    self.x[i,:] = self.xi
                else:
                    j = 0
                    while j < self.vector_size:
                        self.x[i,j:j+self.dof] = self.x[i-1,j:j+self.dof] + self.xdp[i, j:j+self.dof] * self.dtC
                        self.xd[i,j:j+self.dof] = self.xdp[i, j:j+self.dof]
                        j += self.dof
        elif sin:
            if (self.printing > 1):
                print('MD_Driver: Sin driving function')
            self.sin() 
            for i in range(len(self.time)):
                if i == 0:
                    self.x[i,:] = self.xi
                else:
                    j = 0
                    while j < self.vector_size:
                        self.x[i,j:j+self.dof] = self.x[i-1,j:j+self.dof] + self.xdp[i, 0:self.dof] * self.dtC
                        self.xd[i,j:j+self.dof] = self.xdp[i, 0:self.dof]
                        j += self.dof

        # Specifying correct dtypes for conversion to C
        self.xi = np.array(self.xi, dtype = float) 
        self.x = np.array(self.x, dtype = float)
        self.xd = np.array(self.xd, dtype = float)

    def run_v1 (self, dylib = None): 
        #Double vector pointer data type
        double_p = ctypes.POINTER(ctypes.c_double)
        # -------------------- load the MoorDyn DLL ---------------------

        # Make MoorDyn function prototypes and parameter lists (remember, first entry is return type, rest are args)
        MDInitProto = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.POINTER(ctypes.c_double*6), ctypes.POINTER(ctypes.c_double*6)) #need to add filename option here, maybe this c_char works? #need to determine char size 
        MDStepProto = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.POINTER(ctypes.c_double*6), ctypes.POINTER(ctypes.c_double*6), ctypes.POINTER(ctypes.c_double*6), double_p, double_p)
        MDClosProto = ctypes.CFUNCTYPE(ctypes.c_int)

        MDInitParams = (1, "x"), (1, "xd")
        MDStepParams = (1, "x"), (1, "xd"), (2, "f"), (1, "t"), (1, "dtC") 

        if dylib == None:
            # dylib = 'MD_libraries/v1_DYLIB/MoorDyn.dylib'
            dylib = '/Users/rdavies/work/MoorDyn_ryan/MD_extra_branch/compileDYLIB/MoorDyn.dylib'
        MDdylib = ctypes.CDLL(dylib) #load moordyn dylib

        MDInit = MDInitProto(("LinesInit", MDdylib), MDInitParams)
        MDStep = MDStepProto(("LinesCalc", MDdylib), MDStepParams)
        MDClose= MDClosProto(("LinesClose", MDdylib))
        # ------------------------ run MoorDyn ---------------------------
        if (self.printing > 0):   
            print("MD_Driver: Running MoorDynV1")
        # initialize some arrays for communicating with MoorDyn
        t  = double_p()    # pointer to t
        # Converting to ctypes
        dtC = ctypes.pointer(ctypes.c_double(self.dtC))

        # initialize MoorDyn at origin
        MDInit((self.xp[0,:]).ctypes.data_as(ctypes.POINTER(ctypes.c_double*6)),(self.xdp[0,:]).ctypes.data_as(ctypes.POINTER(ctypes.c_double*6)))

        # loop through coupling time steps
        if (self.printing > 1):
            print("MD_Driver: MoorDyn initialized - now performing calls to MoorDynStep...")
        for i in range(len(self.time)):
            t = ctypes.pointer(ctypes.c_double(self.time[i]))
            MDStep((self.xp[i,:]).ctypes.data_as(ctypes.POINTER(ctypes.c_double*6)), (self.xdp[i,:]).ctypes.data_as(ctypes.POINTER(ctypes.c_double*6)), t, dtC)     
            
        # close MoorDyn simulation (clean up the internal memory, hopefully) when finished
        MDClose()   
        if (self.printing > 0):
            print("MD_Driver: v1 script completed")
            print("MD_Driver: --------------------------------------------------")
        del MDdylib

    def run_old_API (self, version = None, dylib = None): 
        if (self.printing > 0):
            print("MD_Driver: Running MoorDyn"+version)
        # -------------------- load the MoorDyn DLL ---------------------

        #Double vector pointer data type
        double_p = ctypes.POINTER(ctypes.c_double)

        # Make MoorDyn function prototypes and parameter lists (remember, first entry is return type, rest are args)
        MDInitProto = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.POINTER(ctypes.c_double*self.vector_size), ctypes.POINTER(ctypes.c_double*self.vector_size), ctypes.c_char_p) #need to add filename option here, maybe this c_char works? #need to determine char size 
        MDStepProto = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.POINTER(ctypes.c_double*self.vector_size), ctypes.POINTER(ctypes.c_double*self.vector_size), ctypes.POINTER(ctypes.c_double*self.vector_size), double_p, double_p)
        MDClosProto = ctypes.CFUNCTYPE(ctypes.c_int)

        MDInitParams = (1, "x"), (1, "xd"), (1, "infilename") #guessing the 1 flag here means input?
        MDStepParams = (1, "x"), (1, "xd"), (2, "f"), (1, "t"), (1, "dtC") 

        if dylib == None:
            if version == "C":
                dylib_path = "MD_libraries/v2_DYLIB/libmoordyn2.dylib"
            else:
                if (self.printing > 0):
                    print("MD_Driver: Please specify version for old_API run")
                return
        else:
            dylib_path = dylib

        if (self.printing > 1):
            print("MD_Driver: dylib path is ", dylib_path)
        MDdylib = ctypes.CDLL(dylib_path) #load moordyn dylib

        filename = self.path+self.rootname+version+self.extension

        MDInit = MDInitProto(("MoorDynInit", MDdylib), MDInitParams)
        MDStep = MDStepProto(("MoorDynStep", MDdylib), MDStepParams)
        MDClose= MDClosProto(("MoorDynClose", MDdylib))  
        # ------------------------ run MoorDyn ---------------------------
        # initialize some arrays for communicating with MoorDyn
        t  = double_p()    # pointer to t

        # parameters
        dtC = ctypes.pointer(ctypes.c_double(self.dtC))

        infile = ctypes.c_char_p(bytes(filename, encoding='utf8'))

        # initialize MoorDyn at origin
        MDInit((self.x[0,:]).ctypes.data_as(ctypes.POINTER(ctypes.c_double*self.vector_size)),(self.xd[0,:]).ctypes.data_as(ctypes.POINTER(ctypes.c_double*self.vector_size)),infile)
        if (self.printing > 1):
            print("MD_Driver: MoorDyn initialized - now performing calls to MoorDynStep...")

        # loop through coupling time steps
        for i in range(len(self.time)):
            t = ctypes.pointer(ctypes.c_double(self.time[i]))
            MDStep((self.x[i,:]).ctypes.data_as(ctypes.POINTER(ctypes.c_double*self.vector_size)), (self.xd[i,:]).ctypes.data_as(ctypes.POINTER(ctypes.c_double*self.vector_size)), t, dtC)    
        # close MoorDyn simulation (clean up the internal memory, hopefully) when finished
        MDClose()   
        if (self.printing > 0):
            print("MD_Driver: Old API {} script completed".format(version))
            print("MD_Driver: --------------------------------------------------")
        del MDdylib

    def run_Cpy (self): 

        if (self.printing > 0):
            print("MD_Driver: This runs the python wrapper of MoorDynV2, it does not reference the local MoorDyn copy that is being edited in ../MoorDyn") # TODO: change pathname
        system = moordyn.Create(self.path+self.rootname+"Cpy"+self.extension)
        moordyn.Init(system, self.x[0,:], self.xd[0,:])
        # loop through coupling time steps
        if (self.printing > 1):
            print("MD_Driver: MoorDyn initialized - now performing calls to MoorDynStep...")
        for i in range(len(self.time)):
            # call the MoorDyn step function
            moordyn.Step(system, self.x[i,:], self.xd[i,:], self.time[i], self.dtC)    #force value returned here in array

        # close MoorDyn simulation (clean up the internal memory, hopefully) when finished
        moordyn.Close(system)   

        if (self.printing > 0):
            print("MD_Driver: Python v2 script executed successfully")
            print("MD_Driver: --------------------------------------------------")
        del system

    def run_fortran(self, driverf_path = None):

        if driverf_path == None:
            driverf_path = "/Users/rdavies/work/MoorDyn_ryan/MoorDynF/build/modules/moordyn/"

        # Remove previous outputs and logs 
        if (self.printing > 1):
            print("MD_Driver: Removing *.log and *.out from ", driverf_path)
        os.system("rm {}*.out".format(driverf_path))
        os.system("rm {}*.log".format(driverf_path))
        os.system('rm MD_fortran_input/PtfmMotions.dat')

        # Creating platform position data if not static
        static = self.dynamics_args.get('static', True)
        outFileName = "MD_fortran_input/PtfmMotions.dat" # writes as radians, required input format for openfast
        if not static:
            if self.num_coupled>0:
                os.system("cp MooringTest/ptfm_motions.dat {}".format(outFileName))
                if (self.printing > 0):
                    print("MD_Driver: WARNING: Currently copying ptfm_motions.dat directly for fortran use, wont work if prescribed rotations")
        else:
            with open(outFileName, 'w') as myfile:     # open an input stream to the line data input file
                if (self.printing > 1):
                    print("MD_Driver: Writing pltfm positions to ", outFileName) 
                i=0  # file line number
                if self.dof == 6:
                    header = ["# Time    PtfmSurge    PtfmSway    PtfmHeave    PtfmRoll(rad)    PtfmPitch(rad)    PtfmYaw(rad) \n"]
                else:
                    header = ['# Time ']
                    for i in range(self.num_coupled):
                        header.append('Fair{}Surge    Fair{}Sway    Fair{}Heave   '.format(i,i,i))
                    header.append('\n')
                myfile.writelines(header)
                for j in range(int(len(self.time))):
                    datarow = self.x[j]
                    value = 0.0
                    line = ""
                    for k in range(0,self.vector_size+1):
                        if k == 0:
                            line += (str(self.time[j])) + "   "
                        else:
                            if k <= len(datarow):
                                value = datarow[k-1] 
                            line += (str(value)) + "   "
                
                    myfile.writelines([line, "\n"])
                    j += 1
        # running MD fortran

        os.system("{}/moordyn_driver MD_fortran_input/MoorDyn.dvr".format(driverf_path))

        # standardizing file names

        files = os.listdir('MooringTest/')
        for file in files:
            components = file.split('.')
            if ('MD' in components) and ('F'in components):
                components.remove('MD')
                components.remove('F')
                if len(components) == 1:
                    new_name = self.rootname+'F.'+ components[0]
                else:
                    new_name = self.rootname+'F_'+ ('.'.join(map(str, components)))
                os.system('mv MooringTest/{} MooringTest/{}'.format(file, new_name)) 

        os.system('rm fort.10')
        if (self.printing > 0):
            print("MD_Driver: MDF script executed successfully")
            print("MD_Driver: --------------------------------------------------")

    def simulate (self):

        run_v1 = self.versions.get('run_v1', True)
        run_cpy = self.versions.get('run_cpy', True)
        run_c = self.versions.get('run_c', True)
        run_f = self.versions.get('run_f', True)

        if (self.printing > 0):
            print("MD_Driver: System initialized, now simulating versions of MoorDyn")
            print("MD_Driver: ------------------------------------------------------")
        if os.path.isfile("MooringTest/*.out") or os.path.isfile("Mooring/*.out"):
            os.system('rm Mooring*/*.out')
            os.system('echo "Removed files with .out extension from Mooring*"')

        if os.path.isfile("MooringTest/*.log") or os.path.isfile("Mooring/*.log"):
            os.system('rm Mooring*/*.log')
            os.system('echo "Removed files with .log extension from Mooring*"')
       
        if run_f:
            os.system("cp {} {}".format(self.path+self.rootname+self.extension, "MD_fortran_input/"+self.rootname+"F"+self.extension))
            self.run_fortran(driverf_path="/Users/rdavies/work/MoorDyn_ryan/MoorDynF/build/modules/moordyn")
            # self.run_fortran(driverf_path="/Users/rdavies/work/MoorDyn_ryan/openfast/build/modules/moordyn")
            # self.run_fortran(driverf_path="/Users/rdavies/Downloads/openfast-3.2.0/build/modules/moordyn")
       
        if run_c:
            os.system("cp {} {}".format(self.path+self.rootname+self.extension, self.path+self.rootname+"C"+self.extension))
            self.run_old_API(version = "C", dylib = '/Users/rdavies/work/MoorDyn_ryan/MoorDyn/compile/DYLIB/libmoordyn2.dylib')
            # self.run_old_API(version = "C", dylib = '/Users/rdavies/work/MoorDyn_ryan/MoorDyn/build/source/libmoordyn.dylib')

        if run_cpy:
            os.system("cp {} {}".format(self.path+self.rootname+self.extension, self.path+self.rootname+"Cpy"+self.extension))
            self.run_Cpy()

        if run_v1: 
            self.run_v1()
            os.system("OS_scripts/namechange_v1")
            os.system("mv Mooring/*_*.out MooringTest/")
            os.system("mv Mooring/*_*.log MooringTest/")

    def run(self, run_args = {}):

        self.printing = run_args.get('printing', 1)
        simulate = run_args.get('simulate', True)
        plot = run_args.get('plot', True)
        del_logs = run_args.get('del_logs', True)
        self.rootname = run_args.get('rootname', 'lines')
        self.extension = run_args.get('extension', '.txt')
        self.path = run_args.get('path', 'MooringTest/')
        self.tMax = run_args.get('tMax', 60)
        self.dof = run_args.get('dof', 3)
        remove_version_inputs = run_args.get('remove_version_inputs', True)
        run_v1 = self.versions.get('run_v1', True)
        run_f = self.versions.get('run_f', True)
        dt_scaling = self.versions.get('dt_scaling', 1.0)

        #------------------- Set up Mooring line conditions -----------------------------

        if (self.printing > 1):
            print("MD_Driver: Loading input data...")
        from_saved_runs = self.plot_args.get('from_saved_runs', True)

        if from_saved_runs:
            out_dirname = "outputs/"+self.rootname+"_outputs/"
        else:
            out_dirname = self.path
        
        inputs = load_infile(in_dirname = self.path, out_dirname = out_dirname, rootname = self.rootname, extension = self.extension, tMax = self.tMax, printing = self.printing)

        # parameters
        self.dtC = float(inputs.MDoptions["dtM"]) * dt_scaling
        self.WtrDnsty = float(inputs.MDoptions.get('WtrDnsty', 1025.0))
        self.WtrDpth = float(inputs.MDoptions['WtrDpth'])
        self.num_coupled = inputs.num_coupled

        # Inital fairlead locations
        self.vector_size = int(inputs.num_coupled*self.dof)
        self.xi = np.zeros(self.vector_size)
        i = 0
        if self.dof == 3:
            for point in inputs.pointList:
                if point.type == -1:  
                    self.xi[i]=(point.r[0])
                    self.xi[i+1]=(point.r[1])
                    self.xi[i+2]=(point.r[2])
                    i += self.dof
        if self.dof == 6 :
            for body in inputs.bodyList:
                if body.type == -1:  
                    self.xi[i]=(body.r6[0])
                    self.xi[i+1]=(body.r6[1])
                    self.xi[i+2]=(body.r6[2])
                    self.xi[i+3]=(body.r6[3])
                    self.xi[i+4]=(body.r6[4])
                    self.xi[i+5]=(body.r6[5])
                    i += self.dof
            # TODO: implement coupled rod support (orentations still need to be figured out)
            for rod in inputs.rodList:
                if rod.coupled == 1:  
                    self.xi[i]=(rod.rA[0])
                    self.xi[i+1]=(rod.rA[1])
                    self.xi[i+2]=(rod.rA[2])
                    self.xi[i+3]=0
                    self.xi[i+4]=np.pi
                    self.xi[i+5]=0
                    i += self.dof

        self.load_dynamics()
        
        if simulate: 
            if run_v1:
                if (self.printing > 1):
                    print("MD_Driver: Converting v2 input file into v1 format...")
                inputs.v1_build(outfile = "Mooring/lines.txt")

            if run_f:
                if (self.printing > 1):
                    print("MD_Driver: Building files for MoorDynF...")
                self.MDf_build()

            self.simulate()
            
            if plot:                        
                self.plot_args['from_saved_runs'] = False
                inputs.figures(plot_args = self.plot_args, versions = self.versions, tMax = self.tMax)

            self.save_outputs (remove_version_inputs = remove_version_inputs, del_logs = del_logs)

        elif plot:
            self.plot_args['from_saved_runs'] = True
            inputs.figures(plot_args = self.plot_args, versions = self.versions, tMax = self.tMax)
        else:
            if (self.pringing > 0 ):
                print("MD_Driver: Please specify appropriate run options. Quitting...")
            exit()

        if plot:
            plt.close('all')

        if (self.printing > 0):
            print('MD_Driver: ------------end--------------')
    
    def save_outputs(self, remove_version_inputs = True, del_logs = True):
        if not os.path.isdir("outputs/"):
            os.system("mkdir outputs/")
        if not os.path.isdir("outputs/{}_outputs/".format(self.rootname)):
            os.system("mkdir outputs/{}_outputs/".format(self.rootname))
        if self.plot_args.get("save", False) and not os.path.isdir("outputs/figures/"):
            os.system("mkdir outputs/figures/")
        os.system("mv MooringTest/*.out outputs/{}_outputs/".format(self.rootname))
        os.system("mv MooringTest/*.log outputs/{}_outputs/".format(self.rootname))
        os.system("mv MooringTest/figures/* outputs/figures/{}".format(self.rootname))
        os.system("OS_scripts/clean_outputs > OS_output.txt")
        if del_logs:
            os.system("rm outputs/{}_outputs/*.log".format(self.rootname))

        if (self.printing > 0):
            print("MD_Driver: Output files from versions saved to outputs/{}_outputs/".format(self.rootname))
            print("MD_Driver: Files of the form Line_Line*.out are v1 output files")

        if remove_version_inputs:
            os.system("rm {}".format(self.path+self.rootname+"C"+self.extension))
            os.system("rm {}".format(self.path+self.rootname+"Cpy"+self.extension))
            os.system("rm MD_fortran_input/{}".format(self.rootname+'F'+self.extension))

